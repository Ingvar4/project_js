<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <link rel="shortcut icon" href="../images/image3.png" type="image/x-icon">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JS LAIR</title>
  <link rel="stylesheet" href="../styles/fonts.css">
  <link rel="stylesheet" href="../styles/style-pages.css">
  <link rel="stylesheet" href="../styles/prism.css">
  <script src="../scripts/prism.js" defer></script>
  <script src="../scripts/script.js" defer></script>
</head>
<body>
  
  <header class="header">
    <ul>
      <li><a href="../index.html">Дом</a></li>
      <li><a href="../pages/browse.html">Просмотр</a></li>
      <li><a href="../pages/other.html">Прочее</a></li>
      <li><a href="#">Проект</a></li>
    </ul>
  </header>

  <article>
    <h1>Рекурсия и стек.</h1>
    <hr>
    <p>Рекурсия – это приём программирования, полезный в ситуациях, когда задача может быть естественно разделена на несколько аналогичных, но более простых задач. Или когда задача может быть упрощена до несложных действий плюс простой вариант той же задачи. Или, как мы скоро увидим, для работы с определёнными структурами данных.</p>
    <p>В процессе выполнения задачи в теле функции могут быть вызваны другие функции для выполнения подзадач. Частный случай подвызова – когда функция вызывает сама себя. Это как раз и называется рекурсией.</p>

    <h3>Два способа мышления</h3>
    <p>В качестве первого примера напишем функцию <code>pow(x, n)</code>, которая возводит x в натуральную степень <code>n</code>. Иначе говоря, умножает <code>x</code> на само себя <code>n</code> раз.</p>
<pre>
  <code class="lang-js">
    pow(2, 2) = 4
    pow(2, 3) = 8
    pow(2, 4) = 16
  </code>
</pre>
    <p>Рассмотрим два способа её реализации.</p>
    <ul>
      <li>Итеративный способ: цикл for:</li>
    </ul>
<pre>
  <code class="lang-js">
    function pow(x, n) {
      let result = 1;
    
      // умножаем result на x n раз в цикле
      for (let i = 0; i < n; i++) {
        result *= x;
      }
    
      return result;
    }
    
    alert( pow(2, 3) ); // 8
  </code>
</pre>
      <ul>
        <li>Рекурсивный способ: упрощение задачи и вызов функцией самой себя:</li>
      </ul>
<pre>
  <code class="lang-js">
    function pow(x, n) {
      if (n == 1) {
        return x;
      } else {
        return x * pow(x, n - 1);
      }
    }
    
    alert( pow(2, 3) ); // 8
  </code>
</pre>
    <p>Обратите внимание, что рекурсивный вариант отличается принципиально.</p>
    <p>Когда функция <code>pow(x, n)</code> вызывается, исполнение делится на две ветви:</p>
<pre>
  <code class="lang-js">
        if n==1  = x
        /
    pow(x, n) =
        \
        else     = x * pow(x, n - 1)
  </code>
</pre>
    <ul>
      <li>Если <code>n == 1</code>, тогда всё просто. Эта ветвь называется базой рекурсии, потому что сразу же приводит к очевидному результату: <code>pow(x, 1)</code> равно <code>x</code>.</li>
      <li>Мы можем представить <code>pow(x, n)</code> в виде: <code>x * pow(x, n - 1)</code>. Что в математике записывается как: <code>xn = x * xn-1</code>. Эта ветвь – шаг рекурсии: мы сводим задачу к более простому действию (умножение на <code>x</code>) и более простой аналогичной задаче (<code>pow</code> с меньшим <code>n</code>). Последующие шаги упрощают задачу всё больше и больше, пока n не достигает <code>1</code>.</li>
    </ul>
    <p>Говорят, что функция <code>pow</code> рекурсивно вызывает саму себя до <code>n == 1</code>.</p>
    <ul><img src="../images/10.JPG" alt="1"></ul>
    <p>Например, рекурсивный вариант вычисления <code>pow(2, 4)</code> состоит из шагов:</p>
    <ul>
      <li><code>pow(2, 4) = 2 * pow(2, 3)</code></li>
      <li><code>pow(2, 3) = 2 * pow(2, 2)</code></li>
      <li><code>pow(2, 2) = 2 * pow(2, 1)</code></li>
      <li><code>pow(2, 1) = 2</code></li>
    </ul>
    <p>Итак, рекурсию используют, когда вычисление функции можно свести к её более простому вызову, а его – к ещё более простому и так далее, пока значение не станет очевидно.</p>
    <hr>
    <h3>Рекурсивное решение обычно короче</h3>
    <p>Рекурсивное решение задачи обычно короче, чем итеративное.</p>
    <p>спользуя условный оператор <code>?</code> вместо <code>if</code>, мы можем переписать <code>pow(x, n)</code>, делая код функции более лаконичным, но всё ещё легко читаемым:</p>
<pre>
  <code class="lang-js">
    function pow(x, n) {
      return (n == 1) ? x : (x * pow(x, n - 1));
    }
  </code>
</pre>
    <p>Общее количество вложенных вызовов (включая первый) называют глубиной рекурсии. В нашем случае она будет равна <code>n</code>.</p>
    <p>Максимальная глубина рекурсии ограничена движком JavaScript. Точно можно рассчитывать на 10000 вложенных вызовов, некоторые интерпретаторы допускают и больше, но для большинства из них 100000 вызовов – за пределами возможностей. Существуют автоматические оптимизации, помогающие избежать переполнения стека вызовов («оптимизация хвостовой рекурсии»), но они ещё не поддерживаются везде и работают только для простых случаев.</p>
    <p>Это ограничивает применение рекурсии, но она всё равно широко распространена: для решения большого числа задач рекурсивный способ решения даёт более простой код, который легче поддерживать.</p>
    <hr>

    <h2>Контекст выполнения, стек</h2>

  </article>
</body>
</html>