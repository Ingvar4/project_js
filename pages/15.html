<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <link rel="shortcut icon" href="../images/image3.png" type="image/x-icon">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JS LAIR</title>
  <link rel="stylesheet" href="../styles/fonts.css">
  <link rel="stylesheet" href="../styles/style-pages.css">
  <link rel="stylesheet" href="../styles/prism.css">
  <script src="../scripts/prism.js" defer></script>
  <script src="../scripts/script.js" defer></script>
</head>
<body>
  
  <header class="header">
    <ul>
      <li><a href="../index.html">Дом</a></li>
      <li><a href="../pages/browse.html">Просмотр</a></li>
      <li><a href="../pages/other.html">Прочее</a></li>
      <li><a href="#">Проект</a></li>
    </ul>
  </header>

  <article>
    <h1>Рекурсия и стек.</h1>
    <hr>
    <p>Рекурсия – это приём программирования, полезный в ситуациях, когда задача может быть естественно разделена на несколько аналогичных, но более простых задач. Или когда задача может быть упрощена до несложных действий плюс простой вариант той же задачи. Или, как мы скоро увидим, для работы с определёнными структурами данных.</p>
    <p>В процессе выполнения задачи в теле функции могут быть вызваны другие функции для выполнения подзадач. Частный случай подвызова – когда функция вызывает сама себя. Это как раз и называется рекурсией.</p>

    <h3>Два способа мышления</h3>
    <p>В качестве первого примера напишем функцию <code>pow(x, n)</code>, которая возводит x в натуральную степень <code>n</code>. Иначе говоря, умножает <code>x</code> на само себя <code>n</code> раз.</p>
<pre>
  <code class="lang-js">
    pow(2, 2) = 4
    pow(2, 3) = 8
    pow(2, 4) = 16
  </code>
</pre>
    <p>Рассмотрим два способа её реализации.</p>
    <ul>
      <li>Итеративный способ: цикл for:</li>
    </ul>
<pre>
  <code class="lang-js">
    function pow(x, n) {
      let result = 1;
    
      // умножаем result на x n раз в цикле
      for (let i = 0; i < n; i++) {
        result *= x;
      }
    
      return result;
    }
    
    alert( pow(2, 3) ); // 8
  </code>
</pre>
      <ul>
        <li>Рекурсивный способ: упрощение задачи и вызов функцией самой себя:</li>
      </ul>
<pre>
  <code class="lang-js">
    function pow(x, n) {
      if (n == 1) {
        return x;
      } else {
        return x * pow(x, n - 1);
      }
    }
    
    alert( pow(2, 3) ); // 8
  </code>
</pre>
    <p>Обратите внимание, что рекурсивный вариант отличается принципиально.</p>
    <p>Когда функция <code>pow(x, n)</code> вызывается, исполнение делится на две ветви:</p>
<pre>
  <code class="lang-js">
        if n==1  = x
        /
    pow(x, n) =
        \
        else     = x * pow(x, n - 1)
  </code>
</pre>
    <ul>
      <li>Если <code>n == 1</code>, тогда всё просто. Эта ветвь называется базой рекурсии, потому что сразу же приводит к очевидному результату: <code>pow(x, 1)</code> равно <code>x</code>.</li>
      <li>Мы можем представить <code>pow(x, n)</code> в виде: <code>x * pow(x, n - 1)</code>. Что в математике записывается как: <code>xn = x * xn-1</code>. Эта ветвь – шаг рекурсии: мы сводим задачу к более простому действию (умножение на <code>x</code>) и более простой аналогичной задаче (<code>pow</code> с меньшим <code>n</code>). Последующие шаги упрощают задачу всё больше и больше, пока n не достигает <code>1</code>.</li>
    </ul>
    <p>Говорят, что функция <code>pow</code> рекурсивно вызывает саму себя до <code>n == 1</code>.</p>
    <ul><img src="../images/10.JPG" alt="1"></ul>
    <p>Например, рекурсивный вариант вычисления <code>pow(2, 4)</code> состоит из шагов:</p>
    <ul>
      <li><code>pow(2, 4) = 2 * pow(2, 3)</code></li>
      <li><code>pow(2, 3) = 2 * pow(2, 2)</code></li>
      <li><code>pow(2, 2) = 2 * pow(2, 1)</code></li>
      <li><code>pow(2, 1) = 2</code></li>
    </ul>
    <p>Итак, рекурсию используют, когда вычисление функции можно свести к её более простому вызову, а его – к ещё более простому и так далее, пока значение не станет очевидно.</p>
    <hr>
    <h3>Рекурсивное решение обычно короче</h3>
    <p>Рекурсивное решение задачи обычно короче, чем итеративное.</p>
    <p>спользуя условный оператор <code>?</code> вместо <code>if</code>, мы можем переписать <code>pow(x, n)</code>, делая код функции более лаконичным, но всё ещё легко читаемым:</p>
<pre>
  <code class="lang-js">
    function pow(x, n) {
      return (n == 1) ? x : (x * pow(x, n - 1));
    }
  </code>
</pre>
    <p>Общее количество вложенных вызовов (включая первый) называют глубиной рекурсии. В нашем случае она будет равна <code>n</code>.</p>
    <p>Максимальная глубина рекурсии ограничена движком JavaScript. Точно можно рассчитывать на 10000 вложенных вызовов, некоторые интерпретаторы допускают и больше, но для большинства из них 100000 вызовов – за пределами возможностей. Существуют автоматические оптимизации, помогающие избежать переполнения стека вызовов («оптимизация хвостовой рекурсии»), но они ещё не поддерживаются везде и работают только для простых случаев.</p>
    <p>Это ограничивает применение рекурсии, но она всё равно широко распространена: для решения большого числа задач рекурсивный способ решения даёт более простой код, который легче поддерживать.</p>
    <hr>

    <h2>Контекст выполнения, стек</h2>
    <p>Теперь мы посмотрим, как работают рекурсивные вызовы. Для этого заглянем «под капот» функций.</p>
    <p>Информация о процессе выполнения запущенной функции хранится в её контексте выполнения (execution context).</p>
    <p>Контекст выполнения – специальная внутренняя структура данных, которая содержит информацию о вызове функции. Она включает в себя конкретное место в коде, на котором находится интерпретатор, локальные переменные функции, значение <code>this</code> (мы не используем его в данном примере) и прочую служебную информацию.</p>
    <p>Один вызов функции имеет ровно один контекст выполнения, связанный с ним.</p>
    <p>Когда функция производит вложенный вызов, происходит следующее:</p>
    <ul>
      <li>Выполнение текущей функции приостанавливается.</li>
      <li>Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – стеке контекстов выполнения.</li>
      <li>Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения.</li>
      <li>После их завершения старый контекст достаётся из стека, и выполнение внешней функции возобновляется с того места, где она была остановлена.</li>
    </ul>
    <p>Разберёмся с контекстами более подробно на примере вызова функции pow(2, 3).</p>

    <h3>pow(2, 3)</h3>
    <p>В начале вызова <code>pow(2, 3)</code> контекст выполнения будет хранить переменные: <code>x = 2</code>, <code>n = 3</code>, выполнение находится на первой строке функции.</p>
    <p>Можно схематически изобразить это так:</p>
    <ul><img src="../images/11.JPG" alt="1"></ul>
    <p>Это только начало выполнения функции. Условие <code>n == 1</code> ложно, поэтому выполнение идёт во вторую ветку <code>if</code>:</p>
<pre>
  <code class="lang-js">
    function pow(x, n) {
      if (n == 1) {
        return x;
      } else {
        return x * pow(x, n - 1);
      }
    }
    
    alert( pow(2, 3) );
  </code>
</pre>
    <p>Значения переменных те же самые, но выполнение функции перешло к другой строке, актуальный контекст:</p>
    <ul><img src="../images/12.JPG" alt="1"></ul>
    <p>Чтобы вычислить выражение <code>x * pow(x, n - 1)</code>, требуется произвести запуск pow с новыми аргументами <code>pow(2, 2)</code>.</p>

    <h3>pow(2, 2)</h3>
    <p>Для выполнения вложенного вызова JavaScript запоминает текущий контекст выполнения в стеке контекстов выполнения.</p>
    <p>Здесь мы вызываем ту же функцию <code>pow</code>, однако это абсолютно неважно. Для любых функций процесс одинаков:</p>
    <ul>
      <li>Текущий контекст «запоминается» на вершине стека.</li>
      <li>Создаётся новый контекст для вложенного вызова.</li>
      <li>Когда выполнение вложенного вызова заканчивается – контекст предыдущего вызова восстанавливается, и выполнение соответствующей функции продолжается.</li>
    </ul>
    <p>Вид контекста в начале выполнения вложенного вызова <code>pow(2, 2)</code>:</p>
    <ul><img src="../images/13.JPG" alt="1"></ul>
    <p>Новый контекст выполнения находится на вершине стека (и выделен жирным), а предыдущие запомненные контексты – под ним.</p>
    <p>Когда выполнение подвызова закончится, можно будет легко вернуться назад, потому что контекст сохраняет как переменные, так и точное место кода, в котором он остановился. Слово «строка» на рисунках условно, на самом деле запоминается более точное место в цепочке команд.</p>

    <h3>pow(2, 1)</h3>
    <p>Процесс повторяется: производится новый вызов в строке 5, теперь с аргументами <code>x=2</code>, <code>n=1</code>.</p>
    <p>Создаётся новый контекст выполнения, предыдущий контекст добавляется в стек:</p>
    <ul><img src="../images/14.JPG" alt="1"></ul>
    <p>Теперь в стеке два старых контекста и один текущий для <code>pow(2, 1)</code>.</p>

    <h3>Выход</h3>
    <p>При выполнении <code>pow(2, 1)</code>, в отличие от предыдущих запусков, условие <code>n == 1</code> истинно, поэтому выполняется первая ветка условия <code>if</code>:</p>
<pre>
  <code class="lang-js">
    function pow(x, n) {
      if (n == 1) {
        return x;
      } else {
        return x * pow(x, n - 1);
      }
    }
  </code>
</pre>
    <p>Вложенных вызовов больше нет, поэтому функция завершается, возвращая <code>2</code>.</p>
    <p>Когда функция заканчивается, контекст её выполнения больше не нужен, поэтому он удаляется из памяти, а из стека восстанавливается предыдущий:</p>
    <ul><img src="../images/15.JPG" alt="1"></ul>
    <p>Возобновляется обработка вызова pow(2, 2). Имея результат pow(2, 1), он может закончить свою работу <code>x * pow(x, n - 1)</code>, вернув <code>4</code>.</p>
    <p>Восстанавливается контекст предыдущего вызова:</p>
    <ul><img src="../images/12.JPG" alt="1"></ul>
    <p>Самый внешний вызов заканчивает свою работу, его результат: <code>pow(2, 3) = 8</code>.</p>
    <p>Глубина рекурсии в данном случае составила 3.</p>
    <p>Как видно из иллюстраций выше, глубина рекурсии равна максимальному числу контекстов, одновременно хранимых в стеке.</p>
    <p>Обратим внимание на требования к памяти. Рекурсия приводит к хранению всех данных для неоконченных внешних вызовов в стеке, и в данном случае это приводит к тому, что возведение в степень <code>n</code> хранит в памяти <code>n</code> различных контекстов.</p>
    <p>Реализация возведения в степень через цикл гораздо более экономна:</p>
<pre>
  <code class="lang-js">
    function pow(x, n) {
      let result = 1;
    
      for (let i = 0; i < n; i++) {
        result *= x;
      }
    
      return result;
    }
  </code>
</pre>
    <p>Итеративный вариант функции <code>pow</code> использует один контекст, в котором будут последовательно меняться значения <code>i</code> и <code>result</code>. При этом объём затрачиваемой памяти небольшой, фиксированный и не зависит от <code>n</code>.</p>
    <ul><strong>Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее.</strong></ul>
    <p>Но переделка рекурсии в цикл может быть нетривиальной, особенно когда в функции в зависимости от условий используются различные рекурсивные подвызовы, результаты которых объединяются, или когда ветвление более сложное. Оптимизация может быть ненужной и совершенно нестоящей усилий.</p>
    <p>Часто код с использованием рекурсии более короткий, лёгкий для понимания и поддержки. Оптимизация требуется не везде, как правило, нам важен хороший код, поэтому она и используется.</p>

    <h3>Рекурсивные обходы</h3>
    <p>Другим отличным применением рекурсии является рекурсивный обход.</p>
    <p>Представьте, у нас есть компания. Структура персонала может быть представлена как объект:</p>
<pre>
  <code class="lang-js">
    let company = {
      sales: [{
        name: 'John',
        salary: 1000
      }, {
        name: 'Alice',
        salary: 600
      }],
    
      development: {
        sites: [{
          name: 'Peter',
          salary: 2000
        }, {
          name: 'Alex',
          salary: 1800
        }],
    
        internals: [{
          name: 'Jack',
          salary: 1300
        }]
      }
    };
  </code>
</pre>
    <p>Другими словами, в компании есть отделы.</p>
    <ul>
      <li>Отдел может состоять из массива работников. Например, в отделе <code>sales</code> работают 2 сотрудника: Джон и Алиса.</li>
      <li>Или отдел может быть разделён на подотделы, например, отдел <code>development</code> состоит из подотделов: <code>sites</code> и <code>internals</code>. В каждом подотделе есть свой персонал.</li>
      <li>Также возможно, что при росте подотдела он делится на подразделения (или команды).</li>
    </ul>
    <p>Например, подотдел <code>sites</code> в будущем может быть разделён на команды <code>siteA</code> и <code>siteB</code>. И потенциально они могут быть разделены ещё. Этого нет на картинке, просто нужно иметь это в виду.</p>
    <p>Теперь, допустим, нам нужна функция для получения суммы всех зарплат. Как мы можем это сделать?</p>
    <p>Итеративный подход не прост, потому что структура довольно сложная. Первая идея заключается в том, чтобы сделать цикл <code>for</code> поверх объекта <code>company</code> с вложенным циклом над отделами 1-го уровня вложенности. Но затем нам нужно больше вложенных циклов для итераций над сотрудниками отделов второго уровня, таких как <code>sites</code>… А затем ещё один цикл по отделам 3-го уровня, которые могут появиться в будущем? Если мы поместим в код 3-4 вложенных цикла для обхода одного объекта, то это будет довольно некрасиво.</p>
    <p>Давайте попробуем рекурсию.</p>
    <p>Как мы видим, когда наша функция получает отдел для подсчёта суммы зарплат, есть два возможных случая:</p>
    <ul>
      <li>Либо это «простой» отдел с массивом – тогда мы сможем суммировать зарплаты в простом цикле.</li>
      <li>Или это объект с <code>N</code> подотделами – тогда мы можем сделать <code>N</code> рекурсивных вызовов, чтобы получить сумму для каждого из подотделов, и объединить результаты.</li>
    </ul>
    <p>Случай (1), когда мы получили массив, является базой рекурсии, тривиальным случаем.</p>
    <p>Случай (2), при получении объекта, является шагом рекурсии. Сложная задача разделяется на подзадачи для подотделов. Они могут, в свою очередь, снова разделиться на подотделы, но рано или поздно это разделение закончится, и решение сведётся к случаю (1).</p>
    <p>Алгоритм даже проще читается в виде кода:</p>
<pre>
  <code class="lang-js">
    let company = { // тот же самый объект, сжатый для краткости
      sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 600 }],
      development: {
        sites: [{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1800 }],
        internals: [{name: 'Jack', salary: 1300}]
      }
    };
    
    // Функция для подсчёта суммы зарплат
    function sumSalaries(department) {
      if (Array.isArray(department)) { // случай (1)
        return department.reduce((prev, current) => prev + current.salary, 0); // сумма элементов массива
      } else { // случай (2)
        let sum = 0;
        for (let subdep of Object.values(department)) {
          sum += sumSalaries(subdep); // рекурсивно вызывается для подотделов, суммируя результаты
        }
        return sum;
      }
    }
    
    alert(sumSalaries(company)); // 6700
  </code>
</pre>
    <p>Код краток и прост для понимания (надеюсь?). В этом сила рекурсии. Она работает на любом уровне вложенности отделов.</p>
    <p>Схема вызовов:</p>
    <ul><img src="../images/16.JPG" alt="1"></ul>
    <p>Принцип прост: для объекта <code>{...}</code> используются рекурсивные вызовы, а массивы <code>[...]</code> являются «листьями» дерева рекурсии, они сразу дают результат.</p>
    <p>Обратите внимание, что в коде используются возможности, о которых мы говорили ранее:</p>
    <ul>
      <li>Метод <code>arr.reduce</code> из главы Методы массивов для получения суммы элементов массива.</li>
      <li>Цикл <code>for(val of Object.values(obj))</code> для итерации по значениям объекта: <code>Object.values</code> возвращает массив значений.</li>
    </ul>

    <h3>Рекурсивные структуры</h3>
    <p>Рекурсивная (рекурсивно определяемая) структура данных – это структура, которая повторяет саму себя в своих частях.</p>
    <p>Мы только что видели это на примере структуры компании выше.</p>
    <p>Отдел компании – это:</p>
    <ul>
      <li>Либо массив людей.</li>
      <li>Либо объект с отделами.</li>
    </ul>
    <p>Для веб-разработчиков существуют гораздо более известные примеры: HTML- и XML-документы.</p>
    <p>В HTML-документе HTML-тег может содержать:</p>
    <ul>
      <li>Фрагменты текста.</li>
      <li>HTML-комментарии.</li>
      <li>Другие HTML-теги (которые, в свою очередь, могут содержать фрагменты текста/комментарии или другие теги и т.д.).</li>
    </ul>
    <p>Это снова рекурсивное определение.</p>
    <p>Для лучшего понимания мы рассмотрим ещё одну рекурсивную структуру под названием «связанный список», которая в некоторых случаях может использоваться в качестве альтернативы массиву.</p>

    <h3>Связанный список</h3>
    <p>Представьте себе, что мы хотим хранить упорядоченный список объектов.</p>
    <p>Естественным выбором будет массив:</p>
<pre>
  <code class="lang-js">
    let arr = [obj1, obj2, obj3];
  </code>
</pre>
    <p>…Но у массивов есть недостатки. Операции «удалить элемент» и «вставить элемент» являются дорогостоящими. Например, операция <code>arr.unshift(obj)</code> должна переиндексировать все элементы, чтобы освободить место для нового <code>obj</code>, и, если массив большой, на это потребуется время. То же самое с <code>arr.shift()</code>.</p>
    <p>Единственные структурные изменения, не требующие массовой переиндексации – это изменения, которые выполняются с конца массива: <code>arr.push/pop</code>. Таким образом, массив может быть довольно медленным для больших очередей, когда нам приходится работать с его началом.</p>
    <p>Или же, если нам действительно нужны быстрые вставка/удаление, мы можем выбрать другую структуру данных, называемую связанный список.</p>
    <p>Элемент связанного списка определяется рекурсивно как объект с:</p>
    <ul>
      <li><code>value</code>,</li>
      <li><code>next</code> – свойство, ссылающееся на следующий элемент связанного списка или null, если это последний элемент.</li>
    </ul>
<pre>
  <code class="lang-js">
    let list = {
      value: 1,
      next: {
        value: 2,
        next: {
          value: 3,
          next: {
            value: 4,
            next: null
          }
        }
      }
    };
  </code>
</pre>
    <p>Графическое представление списка:</p>
    <ul><img src="../images/17.JPG" alt="1"></ul>
    <p>Альтернативный код для создания:</p>
<pre>
  <code class="lang-js">
    let list = { value: 1 };
    list.next = { value: 2 };
    list.next.next = { value: 3 };
    list.next.next.next = { value: 4 };
    list.next.next.next.next = null;
  </code>
</pre>
    <p>Здесь мы можем ещё лучше увидеть, что есть несколько объектов, каждый из которых имеет <code>value</code> и <code>next</code>, указывающий на соседа. Переменная <code>list</code> является первым объектом в цепочке, поэтому, следуя по указателям <code>next</code> из неё, мы можем попасть в любой элемент.</p>
    <p>Список можно легко разделить на несколько частей и впоследствии объединить обратно:</p>
<pre>
  <code class="lang-js">
    let secondList = list.next.next;
    list.next.next = null;
  </code>
</pre>
    <ul><img src="../images/18.JPG" alt="1"></ul>
    <p>Для объединения:</p>
<pre>
  <code class="lang-js">
    list.next.next = secondList;
  </code>
</pre>
    <p>И, конечно, мы можем вставить или удалить элементы из любого места.</p>
    <p>Например, для добавления нового элемента нам нужно обновить первый элемент списка:</p>
<pre>
  <code class="lang-js">
    let list = { value: 1 };
    list.next = { value: 2 };
    list.next.next = { value: 3 };
    list.next.next.next = { value: 4 };
    list.next.next.next.next = null;

    // добавление нового элемента в список
    list = { value: "new item", next: list };
  </code>
</pre>
    <ul><img src="../images/19.JPG" alt="1"></ul>
    <p>Чтобы удалить элемент из середины списка, нужно изменить значение next предыдущего элемента:</p>
<pre>
  <code class="lang-js">
    list.next = list.next.next;
  </code>
</pre>
    <ul><img src="../images/20.JPG" alt="1"></ul>
    <p><code>list.next</code> перепрыгнуло с <code>1</code> на значение <code>2</code>. Значение <code>1</code> теперь исключено из цепочки. Если оно не хранится где-нибудь ещё, оно будет автоматически удалено из памяти.</p>
    <p>В отличие от массивов, нет перенумерации, элементы легко переставляются.</p>
    <p>Естественно, списки не всегда лучше массивов. В противном случае все пользовались бы только списками.</p>
    <p>Главным недостатком является то, что мы не можем легко получить доступ к элементу по его индексу. В простом массиве: <code>arr[n]</code> является прямой ссылкой. Но в списке мы должны начать с первого элемента и перейти в <code>next</code> N раз, чтобы получить N-й элемент.</p>
    <p>…Но нам не всегда нужны такие операции. Например, нам может быть нужна очередь или даже двухсторонняя очередь – это упорядоченная структура, которая позволяет очень быстро добавлять/удалять элементы с обоих концов, но там не нужен доступ в середину.</p>
    <p>Списки могут быть улучшены:</p>
    <ul>
      <li>Можно добавить свойство <code>prev</code> в дополнение к <code>next</code> для ссылки на предыдущий элемент, чтобы легко двигаться по списку назад.</li>
      <li>Можно также добавить переменную <code>tail</code>, которая будет ссылаться на последний элемент списка (и обновлять её при добавлении/удалении элементов с конца).</li>
      <li>…Возможны другие изменения: главное, чтобы структура данных соответствовала нашим задачам с точки зрения производительности и удобства.</li>
    </ul>

    <h3>Итого</h3>
    <p>Термины:</p>
    <ul>
      <li>
        Рекурсия – это термин в программировании, означающий вызов функцией самой себя. Рекурсивные функции могут быть использованы для элегантного решения определённых задач. <br>
        Когда функция вызывает саму себя, это называется шагом рекурсии. База рекурсии – это такие аргументы функции, которые делают задачу настолько простой, что решение не требует дальнейших вложенных вызовов.
      </li>
      <li>
        Рекурсивно определяемая структура данных – это структура данных, которая может быть определена с использованием самой себя. <br>
        Например, связанный список может быть определён как структура данных, состоящая из объекта, содержащего ссылку на список (или null). <br>
        Деревья, такие как дерево HTML-элементов или дерево отделов из этой главы, также являются рекурсивными: у них есть ветви, и каждая ветвь может содержать другие ветви. <br>
        Как мы видели в примере <code>sumSalary</code>, рекурсивные функции могут быть использованы для прохода по ним.
      </li>
    </ul>
    <p>Любая рекурсивная функция может быть переписана в итеративную. И это иногда требуется для оптимизации работы. Но для многих задач рекурсивное решение достаточно быстрое и простое в написании и поддержке.</p>
  </article>
  <button id="scrollToTopButton">&#8593;</button>
</body>
</html>