<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <link rel="shortcut icon" href="../images/image3.png" type="image/x-icon">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JS LAIR</title>
  <link rel="stylesheet" href="../styles/fonts.css">
  <link rel="stylesheet" href="../styles/style-pages.css">
  <link rel="stylesheet" href="../styles/prism.css">
  <script src="../scripts/prism.js" defer></script>
  <script src="../scripts/script.js" defer></script>
</head>
<body>
  
  <header class="header">
    <ul>
      <li><a href="../index.html">Дом</a></li>
      <li><a href="../pages/browse.html">Просмотр</a></li>
      <li><a href="#">Галерея</a></li>
      <li><a href="#">Проект</a></li>
    </ul>
  </header>

  <article>
    <h1 id="object">Объекты.</h1>
    <hr>
    <p>Объекты используются для хранения коллекций различных значений и более сложных сущностей. В JavaScript объекты используются очень часто, это одна из основ языка.</p>
    <p>Объект может быть создан с помощью фигурных скобок <code>{…}</code> с необязательным списком свойств. Свойство – это пара «ключ: значение», где ключ – это строка (также называемая «именем свойства»), а <code>значение</code> может быть чем угодно.</p>
    <p>Мы можем представить объект в виде ящика с подписанными папками. Каждый элемент данных хранится в своей папке, на которой написан ключ. По ключу папку легко найти, удалить или добавить в неё что-либо.</p>
    <p>Пустой объект («пустой ящик») можно создать, используя один из двух вариантов синтаксиса:</p>
<pre>
  <code class="lang-js">
    let user = new Object(); // синтаксис "конструктор объекта"
    let user = {};  // синтаксис "литерал объекта"
  </code>
</pre>
    <p>Обычно используют вариант с фигурными скобками <code>{...}</code>. Такое объявление называют литералом объекта или литеральной нотацией.</p>
    <h3>Литералы и свойства</h3>
    <p>При использовании литерального синтаксиса <code>{...}</code> мы сразу можем поместить в объект несколько свойств в виде пар «ключ: значение»:</p>
<pre>
  <code class="lang-js">
    let user = {     // объект
      name: "John",  // под ключом "name" хранится значение "John"
      age: 30        // под ключом "age" хранится значение 30
    };
  </code>
</pre>
    <p>У каждого свойства есть ключ (также называемый «имя» или «идентификатор»). После имени свойства следует двоеточие <code>":"</code>, и затем указывается значение свойства. Если в объекте несколько свойств, то они перечисляются через запятую.</p>
    <p>В объекте <code>user</code> сейчас находятся два свойства:</p>
    <ul>
      <li>Первое свойство с именем <code>"name"</code> и значением <code>"John"</code>.</li>
      <li>Второе свойство с именем <code>"age"</code> и значением <code>30</code>.</li>
    </ul>
    <p>Можно сказать, что наш объект <code>user</code> – это ящик с двумя папками, подписанными «name» и «age».</p>
    <ul><img src="../images/1.JPG" alt=""></ul>
    <p>Мы можем в любой момент добавить в него новые папки, удалить папки или прочитать содержимое любой папки.</p>
    <p>Для обращения к свойствам используется запись «через точку»:</p>
<pre>
  <code class="lang-js">
    // получаем свойства объекта:
    alert( user.name ); // John
    alert( user.age ); // 30
  </code>
</pre>
    <p>Значение может быть любого типа. Давайте добавим свойство с логическим значением:</p>
<pre>
  <code class="lang-js">
    user.isAdmin = true;
  </code>
</pre>
    <ul><img src="../images/2.JPG" alt=""></ul>
    <p>Для удаления свойства мы можем использовать оператор delete:</p>
<pre>
  <code class="lang-js">
    delete user.age;
  </code>
</pre>
    <ul><img src="../images/3.JPG" alt=""></ul>
    <p>Имя свойства может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки:</p>
<pre>
  <code class="lang-js">
    let user = {
      name: "John",
      age: 30,
      "likes birds": true  // имя свойства из нескольких слов должно быть в кавычках
    };
  </code>
</pre>
    <ul><img src="../images/4.JPG" alt=""></ul>
    <p>Последнее свойство объекта может заканчиваться запятой:</p>
<pre>
  <code class="lang-js">
    let user = {
      name: "John",
      age: 30,
    }
  </code>
</pre>
    <p>Это называется «висячая запятая». Такой подход упрощает добавление, удаление и перемещение свойств, так как все строки объекта становятся одинаковыми.</p>
    <h3>Объект, объявленный как константа, может быть изменён</h3>
    <p>Объект, объявленный через <code>const</code>, может быть изменён.</p>
<pre>
  <code class="lang-js">
    const user = {
      name: "John"
    };
    
    user.name = "Pete"; // (*)
    
    alert(user.name); // Pete
  </code>
</pre>
    <p>Может показаться, что строка <code>(*)</code> должна вызвать ошибку, но нет, здесь всё в порядке. Дело в том, что объявление <code>const</code> защищает от изменений только саму переменную <code>user</code>, а не её содержимое.</p>
    <p>Определение <code>const</code> выдаст ошибку только если мы присвоим переменной другое значение: <code>user=....</code></p>

    <h2>Квадратные скобки</h2>
    <p>Для свойств, имена которых состоят из нескольких слов, доступ к значению «через точку» не работает:</p>
<pre>
  <code class="lang-js">
    // это вызовет синтаксическую ошибку
    user.likes birds = true
  </code>
</pre>
    <p>JavaScript видит, что мы обращаемся к свойству <code>user.likes</code>, а затем идёт непонятное слово <code>birds</code>. В итоге синтаксическая ошибка.</p>
    <p>Точка требует, чтобы ключ был именован по правилам именования переменных. То есть не имел пробелов, не начинался с цифры и не содержал специальные символы, кроме <code>$</code> и <code>_</code>.</p>
    <p>Для таких случаев существует альтернативный способ доступа к свойствам через квадратные скобки. Такой способ сработает с любым именем свойства:</p>
<pre>
  <code class="lang-js">
    let user = {};

    // присваивание значения свойству
    user["likes birds"] = true;

    // получение значения свойства
    alert(user["likes birds"]); // true

    // удаление свойства
    delete user["likes birds"];
  </code>
</pre>
    <p>Сейчас всё в порядке. Обратите внимание, что строка в квадратных скобках заключена в кавычки (подойдёт любой тип кавычек).</p>
    <p>Квадратные скобки также позволяют обратиться к свойству, имя которого может быть результатом выражения. Например, имя свойства может храниться в переменной:</p>
<pre>
  <code class="lang-js">
    let key = "likes birds";

    // то же самое, что и user["likes birds"] = true;
    user[key] = true;
  </code>
</pre>
    <p>Здесь переменная <code>key</code> может быть вычислена во время выполнения кода или зависеть от пользовательского ввода. После этого мы используем её для доступа к свойству. Это даёт нам большую гибкость.</p>
<pre>
  <code class="lang-js">
    let user = {
      name: "John",
      age: 30
    };
    
    let key = prompt("Что вы хотите узнать о пользователе?", "name");
    
    // доступ к свойству через переменную
    alert( user[key] ); // John (если ввели "name")
  </code>
</pre>
    <p>Запись «через точку» такого не позволяет:</p>
<pre>
  <code class="lang-js">
    let user = {
      name: "John",
      age: 30
    };
    
    let key = "name";
    alert( user.key ); // undefined
  </code>
</pre>

    <h2>Вычисляемые свойства</h2>
    <p>Мы можем использовать квадратные скобки в литеральной нотации для создания вычисляемого свойства.</p>
<pre>
  <code class="lang-js">
    let fruit = prompt("Какой фрукт купить?", "apple");

    let bag = {
      [fruit]: 5, // имя свойства будет взято из переменной fruit
    };

    alert( bag.apple ); // 5, если fruit="apple"
  </code>
</pre>
    <p>Смысл вычисляемого свойства прост: запись <code>[fruit]</code> означает, что имя свойства необходимо взять из переменной <code>fruit</code>.</p>
    <p>И если посетитель введёт слово <code>"apple"</code>, то в объекте <code>bag</code> теперь будет лежать свойство <code>{apple: 5}</code>.</p>
    <p>По сути, пример выше работает так же, как и следующий пример:</p>
<pre>
  <code class="lang-js">
    let fruit = prompt("Какой фрукт купить?", "apple");
    let bag = {};

    // имя свойства будет взято из переменной fruit
    bag[fruit] = 5;
  </code>
</pre>
    <p>…Но первый пример выглядит лаконичнее.</p>
    <p>Мы можем использовать и более сложные выражения в квадратных скобках:</p>
<pre>
  <code class="lang-js">
    let fruit = 'apple';
    let bag = {
      [fruit + 'Computers']: 5 // bag.appleComputers = 5
    };
  </code>
</pre>
    <p>Квадратные скобки дают намного больше возможностей, чем запись через точку. Они позволяют использовать любые имена свойств и переменные, хотя и требуют более громоздких конструкций кода.</p>
    <p>Подведём итог: в большинстве случаев, когда имена свойств известны и просты, используется запись через точку. Если же нам нужно что-то более сложное, то мы используем квадратные скобки.</p>

    <h2>Свойство из переменной</h2>
    <p>В реальном коде часто нам необходимо использовать существующие переменные как значения для свойств с тем же именем.</p>
<pre>
  <code class="lang-js">
    function makeUser(name, age) {
      return {
        name: name,
        age: age
        // ...другие свойства
      };
    }
    
    let user = makeUser("John", 30);
    alert(user.name); // John
  </code>
</pre>
    <p>В примере выше название свойств <code>name</code> и <code>age</code> совпадают с названиями переменных, которые мы подставляем в качестве значений этих свойств. Такой подход настолько распространён, что существуют специальные короткие свойства для упрощения этой записи.</p>
    <p>Вместо <code>name:name</code> мы можем написать просто <code>name</code>:</p>
<pre>
  <code class="lang-js">
    function makeUser(name, age) {
      return {
        name, // то же самое, что и name: name
        age   // то же самое, что и age: age
        // ...
      };
    }
  </code>
</pre>
    <p>Мы можем использовать как обычные свойства, так и короткие в одном и том же объекте:</p>
<pre>
  <code class="lang-js">
    let user = {
      name,  // тоже самое, что и name:name
      age: 30
    };
  </code>
</pre>

    <h2>Ограничения на имена свойств</h2>
    <p>Как мы уже знаем, имя переменной не может совпадать с зарезервированными словами, такими как «for», «let», «return» и т.д.</p>
    <p>Но для свойств объекта такого ограничения нет:</p>
<pre>
  <code class="lang-js">
    // эти имена свойств допустимы
    let obj = {
      for: 1,
      let: 2,
      return: 3
    };

    alert( obj.for + obj.let + obj.return );  // 6
  </code>
</pre>
    <p>Иными словами, нет никаких ограничений к именам свойств. Они могут быть в виде строк или символов (специальный тип для идентификаторов, который будет рассмотрен позже).</p>
    <p>Все другие типы данных будут автоматически преобразованы к строке.</p>
    <p>Например, если использовать число <code>0</code> в качестве ключа, то оно превратится в строку <code>"0"</code>:</p>
<pre>
  <code class="lang-js">
    let obj = {
      0: "Тест" // то же самое что и "0": "Тест"
    };
    
    // обе функции alert выведут одно и то же свойство (число 0 преобразуется в строку "0")
    alert( obj["0"] ); // Тест
    alert( obj[0] ); // Тест (то же свойство)
  </code>
</pre>
    <p>Есть небольшой подводный камень, связанный со специальным свойством <code>__proto__</code>. Мы не можем установить его в необъектное значение:</p>
<pre>
  <code class="lang-js">
    let obj = {};
    obj.__proto__ = 5; // присвоим число
    alert(obj.__proto__); // [object Object], значение - это объект, т.е. не то, что мы ожидали
  </code>
</pre>
    <p>Как мы видим, присвоение примитивного значения <code>5</code> игнорируется.</p>

    <h2>Проверка существования свойства, оператор <code>in</code></h2>
    <p>В отличие от многих других языков, особенность JavaScript-объектов в том, что можно получить доступ к любому свойству. Даже если свойства не существует – ошибки не будет!</p>
    <p>При обращении к свойству, которого нет, возвращается <code>undefined</code>. Это позволяет просто проверить существование свойства:</p>
<pre>
  <code class="lang-js">
    let user = {};

    alert( user.noSuchProperty === undefined ); // true означает "свойства нет"
  </code>
</pre>
    <p>Также существует специальный оператор <code>"in"</code> для проверки существования свойства в объекте.</p>
    <p>Синтаксис оператора:</p>
<pre>
  <code class="lang-js">
    "key" in object
  </code>
</pre>
    <p>Пример:</p>
<pre>
  <code class="lang-js">
    let user = { name: "John", age: 30 };

    alert( "age" in user ); // true, user.age существует
    alert( "blabla" in user ); // false, user.blabla не существует
  </code>
</pre>
    <p>Обратите внимание, что слева от оператора <code>in</code> должно быть имя свойства. Обычно это строка в кавычках.</p>
    <p>Если мы опускаем кавычки, это значит, что мы указываем переменную, в которой находится имя свойства. Например:</p>
<pre>
  <code class="lang-js">
    let user = { age: 30 };

    let key = "age";
    alert( key in user ); // true, имя свойства было взято из переменной key
  </code>
</pre>
    <p>Для чего вообще нужен оператор <code>in</code>? Разве недостаточно сравнения с <code>undefined</code>?</p>
    <p>В большинстве случаев прекрасно сработает сравнение с <code>undefined</code>. Но есть особый случай, когда оно не подходит и нужно использовать <code>"in"</code>.</p>
    <p>Это когда свойство существует, но содержит значение <code>undefined</code>:</p>
<pre>
  <code class="lang-js">
    let obj = {
      test: undefined
    };
    
    alert( obj.test ); //  выведет undefined, значит свойство не существует?
    alert( "test" in obj ); // true, свойство существует!
  </code>
</pre>
    <p>В примере выше свойство <code>obj.test</code> технически существует в объекте. Оператор <code>in</code> сработал правильно.</p>
    <p>Подобные ситуации случаются очень редко, так как <code>undefined</code> обычно явно не присваивается. Для «неизвестных» или «пустых» свойств мы используем значение <code>null</code>.</p>

    <h2>Цикл <code>"for..in"</code></h2>
    <p>Для перебора всех свойств объекта используется цикл <code>for..in</code>. Этот цикл отличается от изученного ранее цикла <code>for(;;)</code>.</p>
    <p>Синтаксис:</p>
<pre>
  <code class="lang-js">
    for (key in object) {
      // тело цикла выполняется для каждого свойства объекта
    }
  </code>
</pre>
    <p>К примеру, давайте выведем все свойства объекта <code>user</code>:</p>
<pre>
  <code class="lang-js">
    let user = {
      name: "John",
      age: 30,
      isAdmin: true
    };
    
    for (let key in user) {
      // ключи
      alert( key );  // name, age, isAdmin
      // значения ключей
      alert( user[key] ); // John, 30, true
    }
  </code>
</pre>
    <p>Обратите внимание, что все конструкции <code>for</code> позволяют нам объявлять переменную внутри цикла, как, например, <code>let key</code> здесь.</p>
    <p>Кроме того, мы могли бы использовать другое имя переменной. Например, часто используется вариант <code>"for (let prop in obj)"</code>.</p>

    <h3>Упорядочение свойств объекта</h3>
    <p>Упорядочены ли свойства объекта? Другими словами, если мы будем в цикле перебирать все свойства объекта, получим ли мы их в том же порядке, в котором мы их добавляли? Можем ли мы на это рассчитывать?</p>
    <p>Короткий ответ: свойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания. Разберёмся подробнее.</p>
    <p>В качестве примера рассмотрим объект с телефонными кодами:</p>
<pre>
  <code class="lang-js">
    let codes = {
      "49": "Германия",
      "41": "Швейцария",
      "44": "Великобритания",
      // ..,
      "1": "США"
    };
    
    for (let code in codes) {
      alert(code); // 1, 41, 44, 49
    }
  </code>
</pre>
    <p>Если мы делаем сайт для немецкой аудитории, то, вероятно, мы хотим, чтобы код <code>49</code> был первым.</p>
    <p>Но если мы запустим код, мы увидим совершенно другую картину:</p>
    <ul>
      <li>США (1) идёт первым</li>
      <li>затем Швейцария (41) и так далее.</li>
    </ul>
    <p>Телефонные коды идут в порядке возрастания, потому что они являются целыми числами: <code>1</code>, <code>41</code>, <code>44</code>, <code>49</code>.</p>
    <hr>
    <h3><i>Целочисленные свойства? Это что?</i></h3>
    <p><i>Термин «целочисленное свойство» означает строку, которая может быть преобразована в целое число и обратно без изменений.</i></p>
    <p><i>То есть, <code>"49"</code> – это целочисленное имя свойства, потому что если его преобразовать в целое число, а затем обратно в строку, то оно не изменится. А вот свойства <code>"+49"</code> или <code>"1.2"</code> таковыми не являются:</i></p>
<pre>
  <code class="lang-js">
    // Math.trunc - встроенная функция, которая удаляет десятичную часть
    alert( String(Math.trunc(Number("49"))) ); // "49", то же самое ⇒ свойство целочисленное
    alert( String(Math.trunc(Number("+49"))) ); // "49", не то же самое, что "+49" ⇒ свойство не целочисленное
    alert( String(Math.trunc(Number("1.2"))) ); // "1", не то же самое, что "1.2" ⇒ свойство не целочисленное
  </code>
</pre>
    <hr>
    <p>…С другой стороны, если ключи не целочисленные, то они перебираются в порядке создания, например:</p>
<pre>
  <code class="lang-js">
    let user = {
      name: "John",
      surname: "Smith"
    };
    user.age = 25; // добавим ещё одно свойство
    
    // не целочисленные свойства перечислены в порядке создания
    for (let prop in user) {
      alert( prop ); // name, surname, age
    }
  </code>
</pre>
    <p>Таким образом, чтобы решить нашу проблему с телефонными кодами, мы можем схитрить, сделав коды не целочисленными свойствами. Добавления знака <code>"+"</code> перед каждым кодом будет достаточно.</p>
    <p>Пример:</p>
<pre>
  <code class="lang-js">
    let codes = {
      "+49": "Германия",
      "+41": "Швейцария",
      "+44": "Великобритания",
      // ..,
      "+1": "США"
    };
    
    for (let code in codes) {
      alert( +code ); // 49, 41, 44, 1
    }
  </code>
</pre>

    <h2>Итого</h2>
    <p>Объекты – это ассоциативные массивы с рядом дополнительных возможностей.</p>
    <p>Они хранят свойства (пары ключ-значение), где:</p>
    <ul>
      <li>Ключи свойств должны быть строками или символами (обычно строками).</li>
      <li>Значения могут быть любого типа.</li>
    </ul>
    <p>Чтобы получить доступ к свойству, мы можем использовать:</p>
    <ul>
      <li>Запись через точку: <code>obj.property</code>.</li>
      <li>Квадратные скобки <code>obj["property"]</code>. Квадратные скобки позволяют взять ключ из переменной, например, <code>obj[varWithKey]</code>.</li>
    </ul>
    <p>Дополнительные операторы:</p>
    <ul>
      <li>Удаление свойства: <code>delete obj.prop</code>.</li>
      <li>Проверка существования свойства: <code>"key" in obj</code>.</li>
      <li>Перебор свойств объекта: цикл <code>for for (let key in obj)</code>.</li>
    </ul>
    <p>То, что мы изучали в этой главе, называется «простым объектом» («plain object») или просто <code>Object</code>.</p>
    <p>В JavaScript есть много других типов объектов:</p>
    <ul>
      <li><code>Array</code> для хранения упорядоченных коллекций данных,</li>
      <li><code>Date</code> для хранения информации о дате и времени,</li>
      <li><code>Error</code> для хранения информации об ошибке.</li>
      <li>… и так далее.</li>
    </ul>
    <p>Иногда люди говорят что-то вроде «тип данных Array» или «тип данных Date», но формально они не являются отдельными типами, а относятся к типу данных <code>Object</code>. Они лишь расширяют его различными способами.</p>
  </article>
</body>
</html>