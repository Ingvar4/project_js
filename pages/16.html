<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <link rel="shortcut icon" href="../images/image3.png" type="image/x-icon">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JS LAIR</title>
  <link rel="stylesheet" href="../styles/fonts.css">
  <link rel="stylesheet" href="../styles/style-pages.css">
  <link rel="stylesheet" href="../styles/prism.css">
  <script src="../scripts/prism.js" defer></script>
  <script src="../scripts/script.js" defer></script>
</head>
<body>
  
  <header class="header">
    <ul>
      <li><a href="../index.html">Дом</a></li>
      <li><a href="../pages/browse.html">Просмотр</a></li>
      <li><a href="../pages/other.html">Прочее</a></li>
      <li><a href="#">Проект</a></li>
    </ul>
  </header>

  <article>
    <h1>Деструктурирующее присваивание.</h1>
    <hr>
    
    <p>В JavaScript есть две чаще всего используемые структуры данных – это <code>Object</code> и <code>Array</code>.</p>
    <ul>
      <li>Объекты позволяют нам создавать одну сущность, которая хранит элементы данных по ключам.</li>
      <li>Массивы позволяют нам собирать элементы данных в упорядоченный список.</li>
    </ul>
    <p>Но когда мы передаём их в функцию, то ей может понадобиться не объект/массив целиком, а элементы по отдельности.</p>
    <p>Деструктурирующее присваивание – это специальный синтаксис, который позволяет нам «распаковать» массивы или объекты в несколько переменных, так как иногда они более удобны.</p>
    <p>Деструктуризация также прекрасно работает со сложными функциями, которые имеют много параметров, значений по умолчанию и так далее. Скоро мы увидим это.</p>

    <h2>Деструктуризация массива</h2>
    <p>Вот пример деструктуризации массива на переменные:</p>
<pre>
  <code class="lang-js">
    // у нас есть массив с именем и фамилией
    let arr = ["Ilya", "Kantor"];

    // деструктурирующее присваивание
    // записывает firstName = arr[0]
    // и surname = arr[1]
    let [firstName, surname] = arr;

    alert(firstName); // Ilya
    alert(surname);  // Kantor
  </code>
</pre>
    <p>Теперь мы можем использовать переменные вместо элементов массива.</p>
    <p>Отлично смотрится в сочетании со <code>split</code> или другими методами, возвращающими массив:</p>
<pre>
  <code class="lang-js">
    let [firstName, surname] = "Ilya Kantor".split(' ');
    alert(firstName); // Ilya
    alert(surname);  // Kantor
  </code>
</pre>
    <p>Как вы можете видеть, синтаксис прост. Однако есть несколько странных моментов. Давайте посмотрим больше примеров, чтобы лучше понять это.</p>
    <hr>
    <p><strong>«Деструктуризация» не означает «разрушение».</strong></p>
    <p>«Деструктурирующее присваивание» не уничтожает массив. Оно вообще ничего не делает с правой частью присваивания, его задача – только скопировать нужные значения в переменные.</p>
    <p>Это просто короткий вариант записи:</p>
<pre>
  <code class="lang-js">
    // let [firstName, surname] = arr;
    let firstName = arr[0];
    let surname = arr[1];
  </code>
</pre>
    <hr>
    <p><strong>Пропускайте элементы, используя запятые</strong></p>
    <p>Нежелательные элементы массива также могут быть отброшены с помощью дополнительной запятой:</p>
<pre>
  <code class="lang-js">
    // второй элемент не нужен
    let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

    alert( title ); // Consul
  </code>
</pre>
    <p>В примере выше второй элемент массива пропускается, а третий присваивается переменной <code>title</code>, оставшиеся элементы массива также пропускаются (так как для них нет переменных).</p>
    <hr>
    <p><strong>Работает с любым перебираемым объектом с правой стороны</strong></p>
    <p>…На самом деле мы можем использовать любой перебираемый объект, не только массивы:</p>
<pre>
  <code class="lang-js">
    let [a, b, c] = "abc";
    let [one, two, three] = new Set([1, 2, 3]);
  </code>
</pre>
    <hr>
    <p><strong>Присваивайте чему угодно с левой стороны</strong></p>
    <p>Мы можем использовать что угодно «присваивающее» с левой стороны.</p>
    <p>Например, можно присвоить свойству объекта:</p>
<pre>
  <code class="lang-js">
    let user = {};
    [user.name, user.surname] = "Ilya Kantor".split(' ');

    alert(user.name); // Ilya
    alert(user.surname); // Kantor
  </code>
</pre>
    <hr>
    <p><strong>Цикл с .entries()</strong></p>
    <p>Есть метод Object.entries(obj).</p>
    <p>Мы можем использовать его с деструктуризацией для цикличного перебора ключей и значений объекта:</p>
<pre>
  <code class="lang-js">
    let user = {
      name: "John",
      age: 30
    };
    
    // цикл по ключам и значениям
    for (let [key, value] of Object.entries(user)) {
      alert(`${key}:${value}`); // name:John, затем age:30
    }
  </code>
</pre>
    <p>…то же самое для map:</p>
<pre>
  <code class="lang-js">
    let user = new Map();
    user.set("name", "John");
    user.set("age", "30");

    // Map перебирает как пары [ключ, значение], что очень удобно для деструктурирования
    for (let [key, value] of user) {
      alert(`${key}:${value}`); // name:John, затем age:30
    }
  </code>
</pre>
    <hr>
    <p><strong>Трюк обмена переменных</strong></p>
    <p>Существует хорошо известный трюк для обмена значений двух переменных с использованием деструктурирующего присваивания:</p>
<pre>
  <code class="lang-js">
    let guest = "Jane";
    let admin = "Pete";

    // Давайте поменяем местами значения: сделаем guest = "Pete", а admin = "Jane"
    [guest, admin] = [admin, guest];

    alert(`${guest} ${admin}`); // Pete Jane (успешно заменено!)
  </code>
</pre>
    <p>Здесь мы создаём временный массив из двух переменных и немедленно деструктурируем его в порядке замены.</p>
    <p>Таким образом, мы можем поменять местами даже более двух переменных.</p>
    <hr>

    <h3>Остаточные параметры «…»</h3>
    <p>Обычно, если массив длиннее, чем список слева, «лишние» элементы опускаются.</p>
    <p>Например, здесь берутся только первые два элемента, а остальные просто игнорируются:</p>
<pre>
  <code class="lang-js">
    let [name1, name2] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

    alert(name1); // Julius
    alert(name2); // Caesar
    // Дальнейшие элементы нигде не присваиваются
  </code>
</pre>
    <p>Если мы хотим не просто получить первые значения, но и собрать все остальные, то мы можем добавить ещё один параметр, который получает остальные значения, используя оператор «остаточные параметры» – троеточие ("..."):</p>
<pre>
  <code class="lang-js">
    let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

    // rest это массив элементов, начиная с 3-го
    alert(rest[0]); // Consul
    alert(rest[1]); // of the Roman Republic
    alert(rest.length); // 2
  </code>
</pre>
    <p>Переменная <code>rest</code> является массивом из оставшихся элементов.</p>
    <p>Вместо <code>rest</code> можно использовать любое другое название переменной, просто убедитесь, что перед переменной есть три точки и она стоит на последнем месте в деструктурирующем присваивании.</p>
<pre>
  <code class="lang-js">
    let [name1, name2, ...titles] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
    // теперь titles = ["Consul", "of the Roman Republic"]
  </code>
</pre>

    <h3>Значения по умолчанию</h3>
    <p>Если в массиве меньше значений, чем в присваивании, то ошибки не будет. Отсутствующие значения считаются неопределёнными:</p>
<pre>
  <code class="lang-js">
    let [firstName, surname] = [];

    alert(firstName); // undefined
    alert(surname); // undefined
  </code>
</pre>
    <p>Если мы хотим, чтобы значение «по умолчанию» заменило отсутствующее, мы можем указать его с помощью <code>=</code>:</p>
<pre>
  <code class="lang-js">
    // значения по умолчанию
    let [name = "Guest", surname = "Anonymous"] = ["Julius"];

    alert(name);    // Julius (из массива)
    alert(surname); // Anonymous (значение по умолчанию)
  </code>
</pre>
    <p>Значения по умолчанию могут быть гораздо более сложными выражениями или даже функциями. Они выполняются, только если значения отсутствуют.</p>
    <p>Например, здесь мы используем функцию <code>prompt</code> для указания двух значений по умолчанию.</p>
<pre>
  <code class="lang-js">
    // prompt запустится только для surname
    let [name = prompt('name?'), surname = prompt('surname?')] = ["Julius"];

    alert(name);    // Julius (из массива)
    alert(surname); // результат prompt
  </code>
</pre>
    <p>Обратите внимание, <code>prompt</code> будет запущен только для пропущенного значения (<code>surname</code>).</p>

    <h2>Деструктуризация объекта</h2>
    <p>Деструктурирующее присваивание также работает с объектами.</p>
    <p>Синтаксис:</p>
<pre>
  <code class="lang-js">
    let {var1, var2} = {var1:…, var2:…}
  </code>
</pre>
    <p>У нас есть существующий объект с правой стороны, который мы хотим разделить на переменные. Левая сторона содержит «шаблон» для соответствующих свойств. В простом случае это список названий переменных в {...}.</p>
<pre>
  <code class="lang-js">
    let options = {
      title: "Menu",
      width: 100,
      height: 200
    };
    
    let {title, width, height} = options;
    
    alert(title);  // Menu
    alert(width);  // 100
    alert(height); // 200
  </code>
</pre>
    <p>Свойства <code>options.title</code>, <code>options.width</code> и <code>options.height</code> присваиваются соответствующим переменным.</p>
    <p>Порядок не имеет значения. Вот так – тоже работает:</p>
<pre>
  <code class="lang-js">
    // изменён порядок в let {...}
    let {height, width, title} = { title: "Menu", height: 200, width: 100 }
  </code>
</pre>
    <p>Шаблон с левой стороны может быть более сложным и определять соответствие между свойствами и переменными.</p>
    <p>Если мы хотим присвоить свойство объекта переменной с другим названием, например, свойство <code>options.width</code> присвоить переменной <code>w</code>, то мы можем использовать двоеточие:</p>
<pre>
  <code class="lang-js">
    let options = {
      title: "Menu",
      width: 100,
      height: 200
    };
    
    // { sourceProperty: targetVariable }
    let {width: w, height: h, title} = options;
    
    // width -> w
    // height -> h
    // title -> title
    
    alert(title);  // Menu
    alert(w);      // 100
    alert(h);      // 200
  </code>
</pre>
    <p>Двоеточие показывает «что : куда идёт». В примере выше свойство <code>width</code> сохраняется в переменную <code>w</code>, свойство <code>height</code> сохраняется в <code>h</code>, а <code>title</code> присваивается одноимённой переменной.</p>
    <p>Для потенциально отсутствующих свойств мы можем установить значения по умолчанию, используя "<code>=</code>", как здесь:</p>
<pre>
  <code class="lang-js">
    let options = {
      title: "Menu"
    };
    
    let {width = 100, height = 200, title} = options;
    
    alert(title);  // Menu
    alert(width);  // 100
    alert(height); // 200
  </code>
</pre>
    <p>Как и в случае с массивами, значениями по умолчанию могут быть любые выражения или даже функции. Они выполнятся, если значения отсутствуют.</p>
    <p>В коде ниже prompt запросит <code>width</code>, но не <code>title</code>:</p>
<pre>
  <code class="lang-js">
    let options = {
      title: "Menu"
    };
    
    let {width = prompt("width?"), title = prompt("title?")} = options;
    
    alert(title);  // Menu
    alert(width);  // (результат prompt)
  </code>
</pre>
    <p>Мы также можем совмещать <code>:</code> и <code>=</code>:</p>
<pre>
  <code class="lang-js">
    let options = {
      title: "Menu"
    };
    
    let {width: w = 100, height: h = 200, title} = options;
    
    alert(title);  // Menu
    alert(w);      // 100
    alert(h);      // 200
  </code>
</pre>
    <p>Если у нас есть большой объект с множеством свойств, можно взять только то, что нужно:</p>
<pre>
  <code class="lang-js">
    let options = {
      title: "Menu",
      width: 100,
      height: 200
    };
    
    // взять только title, игнорировать остальное
    let { title } = options;
    
    alert(title); // Menu
  </code>
</pre>

    <h3>Остаток объекта «…»</h3>



  </article>
</body>
</html>