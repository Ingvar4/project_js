<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <link rel="shortcut icon" href="../images/image3.png" type="image/x-icon">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JS LAIR</title>
  <link rel="stylesheet" href="../styles/fonts.css">
  <link rel="stylesheet" href="../styles/style-pages.css">
  <link rel="stylesheet" href="../styles/prism.css">
  <script src="../scripts/prism.js" defer></script>
  <script src="../scripts/script.js" defer></script>
</head>
<body>
  
  <header class="header">
    <ul>
      <li><a href="../index.html">Дом</a></li>
      <li><a href="../pages/browse.html">Просмотр</a></li>
      <li><a href="../pages/other.html">Прочее</a></li>
      <li><a href="#">Проект</a></li>
    </ul>
  </header>

  <article>
    <h1>Методы объекта, "<code>this</code>"</h1>
    <hr>
    <p>Объекты обычно создаются, чтобы представлять сущности реального мира, будь то пользователи, заказы и так далее:</p>
<pre>
  <code class="lang-js">
    // Объект пользователя
    let user = {
      name: "John",
      age: 30
    };
  </code>
</pre>
    <p>И так же, как и в реальном мире, пользователь может совершать действия: выбирать что-то из корзины покупок, авторизовываться, выходить из системы, оплачивать и т.п.</p>
    <p>Такие действия в JavaScript представлены функциями в свойствах.</p>

    <h3>Примеры методов</h3>
    <p>Для начала давайте научим нашего пользователя user здороваться:</p>
<pre>
  <code class="lang-js">
    let user = {
      name: "John",
      age: 30
    };
    
    user.sayHi = function() {
      alert("Привет!");
    };
    
    user.sayHi(); // Привет!
  </code>
</pre>
    <p>Здесь мы просто использовали Function Expression (функциональное выражение), чтобы создать функцию приветствия, и присвоили её свойству <code>user.sayHi</code> нашего объекта.</p>
    <p>Затем мы можем вызвать ee как <code>user.sayHi()</code>. Теперь пользователь может говорить!</p>
    <p>Функцию, которая является свойством объекта, называют <i>методом</i> этого объекта.</p>
    <p>Итак, мы получили метод <code>sayHi</code> объекта <code>user</code>.</p>
    <p>Конечно, мы могли бы использовать заранее объявленную функцию в качестве метода, вот так:</p>
<pre>
  <code class="lang-js">
    let user = {
      // ...
    };
    
    // сначала, объявляем
    function sayHi() {
      alert("Привет!");
    }
    
    // затем добавляем в качестве метода
    user.sayHi = sayHi;
    
    user.sayHi(); // Привет!
  </code>
</pre>
    <hr>
    <p><i><strong>Объектно-ориентированное программирование</strong></i></p>
    <p><i>Когда мы пишем наш код, используя объекты для представления сущностей реального мира, – это называется объектно-ориентированным программированием или сокращённо: «ООП».</i></p>
    <p><i>ООП является большой предметной областью и интересной наукой самой по себе. Как выбрать правильные сущности? Как организовать взаимодействие между ними? Это – создание архитектуры, и на эту тему есть отличные книги, такие как «Приёмы объектно-ориентированного проектирования. Паттерны проектирования» авторов Эрих Гамма, Ричард Хелм, Ральф Джонсон, Джон Влиссидес или «Объектно-ориентированный анализ и проектирование с примерами приложений» Гради Буча, а также ещё множество других книг.</i></p>
    <hr>

    <h3>Сокращённая запись метода</h3>
    <p>Существует более короткий синтаксис для методов в литерале объекта:</p>
<pre>
  <code class="lang-js">
    // эти объекты делают одно и то же

    user = {
      sayHi: function() {
        alert("Привет");
      }
    };

    // сокращённая запись выглядит лучше, не так ли?
    user = {
      sayHi() { // то же самое, что и "sayHi: function(){...}"
        alert("Привет");
      }
    };
  </code>
</pre>
    <p>Как было показано, мы можем пропустить ключевое слово <code>"function"</code> и просто написать <code>sayHi()</code>.</p>
    <p>Нужно отметить, что эти две записи не полностью эквивалентны. Есть тонкие различия, связанные с наследованием объектов (что будет рассмотрено позже), но на данном этапе изучения это неважно. Почти во всех случаях сокращённый синтаксис предпочтителен.</p>

    <h2>Ключевое слово <code>this</code> в методах</h2>
    <p>Как правило, методу объекта обычно требуется доступ к информации, хранящейся в объекте, для выполнения своей работы.</p>
    <p>Например, коду внутри <code>user.sayHi()</code> может потребоваться имя пользователя, которое хранится в объекте <code>user</code>.</p>
    <p><strong>Для доступа к информации внутри объекта метод может использовать ключевое слово this.</strong></p>
    <p>Значение <code>this</code> – это объект «перед точкой», который используется для вызова метода.</p>
<pre>
  <code class="lang-js">
    let user = {
      name: "John",
      age: 30,
    
      sayHi() {
        // "this" - это "текущий объект".
        alert(this.name);
      }
    
    };
    
    user.sayHi(); // John
  </code>
</pre>
    <p>Здесь во время выполнения кода <code>user.sayHi()</code> значением <code>this</code> будет являться <code>user</code> (ссылка на объект <code>user</code>).</p>
    <p>Технически также возможно получить доступ к объекту без ключевого слова <code>this</code>, обратившись к нему через внешнюю переменную (в которой хранится ссылка на этот объект):</p>
<pre>
  <code class="lang-js">
    let user = {
      name: "John",
      age: 30,
    
      sayHi() {
        alert(user.name); // "user" вместо "this"
      }
    };
  </code>
</pre>
    <p>…Но такой код ненадёжен. Если мы решим скопировать ссылку на объект <code>user</code> в другую переменную, например, <code>admin = user</code>, и перезапишем переменную <code>user</code> чем-то другим, тогда будет осуществлён доступ к неправильному объекту при вызове метода из <code>admin</code>.</p>
    <p>Это показано ниже:</p>
<pre>
  <code class="lang-js">
    let user = {
      name: "John",
      age: 30,
    
      sayHi() {
        alert( user.name ); // приведёт к ошибке
      }
    };
    
    let admin = user;
    user = null; // перезапишем переменную для наглядности, теперь она не хранит ссылку на объект.
    
    admin.sayHi(); // TypeError: Cannot read property 'name' of null
  </code>
</pre>
    <p>Если бы мы использовали <code>this.name</code> вместо <code>user.name</code> внутри <code>alert</code>, тогда этот код бы сработал.</p>

    <h3><code>this</code> не является фиксированным</h3>
    <p>В JavaScript ключевое слово <code>this</code> ведёт себя иначе, чем в большинстве других языков программирования. Его можно использовать в любой функции, даже если это не метод объекта.</p>
    <p>В следующем примере нет синтаксической ошибки:</p>
<pre>
  <code class="lang-js">
    function sayHi() {
      alert( this.name );
    }
  </code>
</pre>
    <p>Значение <code>this</code> вычисляется во время выполнения кода, в зависимости от контекста.</p>
    <p>Например, здесь одна и та же функция назначена двум разным объектам и имеет различное значение <code>this</code> в вызовах:</p>
<pre>
  <code class="lang-js">
    let user = { name: "John" };
    let admin = { name: "Admin" };

    function sayHi() {
      alert( this.name );
    }

    // используем одну и ту же функцию в двух объектах
    user.f = sayHi;
    admin.f = sayHi;

    // эти вызовы имеют  разное значение this
    // "this" внутри функции - это объект "перед точкой"
    user.f(); // John  (this == user)
    admin.f(); // Admin  (this == admin)

    admin['f'](); // Admin (нет разницы между использованием точки или квадратных скобок для доступа к объекту)
  </code>
</pre>
    <p>Правило простое: если вызывается <code>obj.f()</code>, то во время вызова <code>f</code>, <code>this</code> – это <code>obj</code>. Так что, в приведённом выше примере это либо <code>user</code>, либо <code>admin</code>.</p>

    <h3>У стрелочных функций нет <code>this</code></h3>
    <p>Стрелочные функции особенные: у них нет своего «собственного» <code>this</code>. Если мы ссылаемся на <code>this</code> внутри такой функции, то оно берётся из внешней «нормальной» функции.</p>
    <p>Например, здесь <code>arrow()</code> использует значение <code>this</code> из внешнего метода <code>user.sayHi()</code>:</p>
<pre>
  <code class="lang-js">
    let user = {
      firstName: "Ilya",
      sayHi() {
        let arrow = () => alert(this.firstName);
        arrow();
      }
    };
    
    user.sayHi(); // Ilya
  </code>
</pre>
    <p>Это особенность стрелочных функций. Она полезна, когда мы на самом деле не хотим иметь отдельное <code>this</code>, а скорее хотим взять его из внешнего контекста. Позже в главе Повторяем стрелочные функции мы увидим больше примеров на эту тему.</p>

    <h2>Итого</h2>
    <ul>
      <li>Функции, которые находятся в свойствах объекта, называются «методами».</li>
      <li>Методы позволяют объектам «действовать»: <code>object.doSomething()</code>.</li>
      <li>Методы могут ссылаться на объект через <code>this</code>.</li>
    </ul>
    <p>Значение <code>this</code> определяется во время исполнения кода.</p>
    <ul>
      <li>При объявлении любой функции в ней можно использовать <code>this</code>, но этот <code>this</code> не имеет значения до тех пор, пока функция не будет вызвана.</li>
      <li>Функция может быть скопирована между объектами (из одного объекта в другой).</li>
      <li>Когда функция вызывается синтаксисом «метода» – <code>object.method()</code>, значением <code>this</code> во время вызова является <code>object</code>.</li>
    </ul>
    <p>Также ещё раз заметим, что стрелочные функции являются особенными – у них нет <code>this</code>. Когда внутри стрелочной функции обращаются к <code>this</code>, то его значение берётся извне.</p>
  </article>
  <button id="scrollToTopButton">&#8593;</button>
</body>
</html>