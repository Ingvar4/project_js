<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <link rel="shortcut icon" href="../images/image3.png" type="image/x-icon">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JS LAIR</title>
  <link rel="stylesheet" href="../styles/fonts.css">
  <link rel="stylesheet" href="../styles/style-pages.css">
  <link rel="stylesheet" href="../styles/prism.css">
  <script src="../scripts/prism.js" defer></script>
  <script src="../scripts/script.js" defer></script>
</head>
<body>
  
  <header class="header">
    <ul>
      <li><a href="../index.html">Дом</a></li>
      <li><a href="../pages/browse.html">Просмотр</a></li>
      <li><a href="../pages/other.html">Прочее</a></li>
      <li><a href="#">Проект</a></li>
    </ul>
  </header>

  <article>
    <h1>Массивы.</h1>
    <hr>
    <p>Для хранения упорядоченных коллекций существует особая структура данных, которая называется массив, <code>Array</code>.</p>
    <h3>Объявление</h3>
    <p>Существует два варианта синтаксиса для создания пустого массива:</p>
<pre>
  <code class="lang-js">
    let arr = new Array();
    let arr = [];
  </code>
</pre>
    <p>Практически всегда используется второй вариант синтаксиса. В скобках мы можем указать начальные значения элементов:</p>
<pre>
  <code class="lang-js">
    let fruits = ["Яблоко", "Апельсин", "Слива"];
  </code>
</pre>
    <p>Элементы массива нумеруются, начиная с нуля.</p>
    <p>Мы можем получить элемент, указав его номер в квадратных скобках:</p>
<pre>
  <code class="lang-js">
    let fruits = ["Яблоко", "Апельсин", "Слива"];

    alert( fruits[0] ); // Яблоко
    alert( fruits[1] ); // Апельсин
    alert( fruits[2] ); // Слива
  </code>
</pre>
    <p>Мы можем заменить элемент:</p>
<pre>
  <code class="lang-js">
    fruits[2] = 'Груша'; // теперь ["Яблоко", "Апельсин", "Груша"]
  </code>
</pre>
    <p>…Или добавить новый к существующему массиву:</p>
<pre>
  <code class="lang-js">
    fruits[3] = 'Лимон'; // теперь ["Яблоко", "Апельсин", "Груша", "Лимон"]
  </code>
</pre>
    <p>Общее число элементов массива содержится в его свойстве <code>length</code>:</p>
<pre>
  <code class="lang-js">
    let fruits = ["Яблоко", "Апельсин", "Слива"];

    alert( fruits.length ); // 3
  </code>
</pre>
    <p>Вывести массив целиком можно при помощи <code>alert</code>.</p>
<pre>
  <code class="lang-js">
    let fruits = ["Яблоко", "Апельсин", "Слива"];

    alert( fruits ); // Яблоко, Апельсин, Слива
  </code>
</pre>
    <p>В массиве могут храниться элементы любого типа.</p>
<pre>
  <code class="lang-js">
    // разные типы значений
    let arr = [ 'Яблоко', { name: 'Джон' }, true, function() { alert('привет'); } ];

    // получить элемент с индексом 1 (объект) и затем показать его свойство
    alert( arr[1].name ); // Джон

    // получить элемент с индексом 3 (функция) и выполнить её
    arr[3](); // привет
  </code>
</pre>
    
    <h3>Получение последних элементов при помощи «at»</h3>
    <p>Допустим, нам нужен последний элемент массива.</p>
    <p>Некоторые языки программирования позволяют использовать отрицательные индексы для той же цели, как-то так: <code>fruits[-1]</code>.</p>
    <p>Однако, в JavaScript такая запись не сработает. Её результатом будет <code>undefined</code>, поскольку индекс в квадратных скобках понимается буквально.</p>
    <p>Мы можем явно вычислить индекс последнего элемента, а затем получить к нему доступ вот так: <code>fruits[fruits.length - 1]</code>.</p>
<pre>
  <code class="lang-js">
    let fruits = ["Apple", "Orange", "Plum"];
    alert( fruits[fruits.length-1] ); // Plum
  </code>
</pre>
    <p>Немного громоздко, не так ли? Нам нужно дважды написать имя переменной.</p>
    <p>К счастью, есть более короткий синтаксис: <code>fruits.at(-1)</code>:</p>
<pre>
  <code class="lang-js">
    let fruits = ["Apple", "Orange", "Plum"];
    // то же самое, что и fruits[fruits.length-1]
    alert( fruits.at(-1) ); // Plum
  </code>
</pre>
    <p>Другими словами, <code>arr.at(i)</code>:</p>
    <ul>
      <li>это ровно то же самое, что и <code>arr[i]</code>, если <code>i >= 0</code>.</li>
      <li>для отрицательных значений <code>i</code>, он отступает от конца массива.</li>
    </ul>

    <h3>Методы pop/push, shift/unshift</h3>
    <p>Очередь – один из самых распространённых вариантов применения массива. В области компьютерных наук так называется упорядоченная коллекция элементов, поддерживающая два вида операций:</p>
    <ul>
      <li><code>push</code> добавляет элемент в конец.</li>
      <li><code>shift</code> удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым.</li>
    </ul>
    <ul><img src="../images/5.JPG" alt="1"></ul>
    <p>Массивы поддерживают обе операции.</p>
    <p>На практике необходимость в этом возникает очень часто. Например, очередь сообщений, которые надо показать на экране.</p>
    <p>Существует и другой вариант применения для массивов – структура данных, называемая стек.</p>
    <p>Она поддерживает два вида операций:</p>
    <ul>
      <li><code>push</code> добавляет элемент в конец.</li>
      <li><code>pop</code> удаляет последний элемент.</li>
    </ul>
    <p>Таким образом, новые элементы всегда добавляются или удаляются из «конца».</p>
    <p>Примером стека обычно служит колода карт: новые карты кладутся наверх и берутся тоже сверху:</p>
    <ul><img src="../images/6.JPG" alt="1"></ul>
    <p>Массивы в JavaScript могут работать и как очередь, и как стек. Мы можем добавлять/удалять элементы как в начало, так и в конец массива.</p>
    <p>В компьютерных науках структура данных, делающая это возможным, называется двусторонняя очередь.</p>
    <p><strong>Методы, работающие с концом массива:</strong></p>
    <p><code>pop</code></p>
    <p>Удаляет последний элемент из массива и возвращает его:</p>
<pre>
  <code class="lang-js">
    let fruits = ["Яблоко", "Апельсин", "Груша"];

    alert( fruits.pop() ); // удаляем "Груша" и выводим его

    alert( fruits ); // Яблоко, Апельсин
  </code>
</pre>
    <p>И <code>fruits.pop()</code> и <code>fruits.at(-1)</code> возвращают последний элемент массива, но <code>fruits.pop()</code> также изменяет массив, удаляя его.</p>
    <p><code>push</code></p>
    <p>Добавляет элемент в конец массива:</p>
<pre>
  <code class="lang-js">
    let fruits = ["Яблоко", "Апельсин"];

    fruits.push("Груша");

    alert( fruits ); // Яблоко, Апельсин, Груша
  </code>
</pre>
    <p>Вызов <code>fruits.push(...)</code> равнозначен <code>fruits[fruits.length] = ....</code></p>
    <p><strong>Методы, работающие с началом массива:</strong></p>
    <p><code>shift</code></p>
    <p>Удаляет из массива первый элемент и возвращает его:</p>
<pre>
  <code class="lang-js">
    let fruits = ["Яблоко", "Апельсин", "Груша"];

    alert( fruits.shift() ); // удаляем Яблоко и выводим его

    alert( fruits ); // Апельсин, Груша
  </code>
</pre>
    <p><code>unshift</code></p>
    <p>Добавляет элемент в начало массива:</p>
<pre>
  <code class="lang-js">
    let fruits = ["Апельсин", "Груша"];

    fruits.unshift('Яблоко');

    alert( fruits ); // Яблоко, Апельсин, Груша
  </code>
</pre>
    <p>Методы <code>push</code> и <code>unshift</code> могут добавлять сразу несколько элементов:</p>
<pre>
  <code class="lang-js">
    let fruits = ["Яблоко"];

    fruits.push("Апельсин", "Груша");
    fruits.unshift("Ананас", "Лимон");

    // ["Ананас", "Лимон", "Яблоко", "Апельсин", "Груша"]
    alert( fruits );
  </code>
</pre>

    <h3>Внутреннее устройство массива</h3>
    <p>Массив – это особый подвид объектов. Квадратные скобки, используемые для того, чтобы получить доступ к свойству arr[0] – это по сути обычный синтаксис доступа по ключу, как <code>obj[key]</code>, где в роли <code>obj</code> у нас <code>arr</code>, а в качестве ключа – числовой индекс.</p>
    <p>Массивы расширяют объекты, так как предусматривают специальные методы для работы с упорядоченными коллекциями данных, а также свойство <code>length</code>. Но в основе всё равно лежит объект.</p>
    <p>Следует помнить, что в JavaScript существует 8 основных типов данных. Массив является объектом и, следовательно, ведёт себя как объект.</p>
    <p>Например, копируется по ссылке:</p>
<pre>
  <code class="lang-js">
    let fruits = ["Банан"]

    let arr = fruits; // копируется по ссылке (две переменные ссылаются на один и тот же массив)

    alert( arr === fruits ); // true

    arr.push("Груша"); // массив меняется по ссылке

    alert( fruits ); // Банан, Груша - теперь два элемента
  </code>
</pre>
    <p>…Но то, что действительно делает массивы особенными – это их внутреннее представление. Движок JavaScript старается хранить элементы массива в непрерывной области памяти, один за другим, так, как это показано на иллюстрациях к этой главе. Существуют и другие способы оптимизации, благодаря которым массивы работают очень быстро.</p>
    <p>Но все они утратят эффективность, если мы перестанем работать с массивом как с «упорядоченной коллекцией данных» и начнём использовать его как обычный объект.</p>
    <p>Например, технически мы можем сделать следующее:</p>
<pre>
  <code class="lang-js">
    let fruits = []; // создаём массив

    fruits[99999] = 5; // создаём свойство с индексом, намного превышающим длину массива

    fruits.age = 25; // создаём свойство с произвольным именем
  </code>
</pre>
    <p>Это возможно, потому что в основе массива лежит объект. Мы можем присвоить ему любые свойства.</p>
    <p>Но движок поймёт, что мы работаем с массивом, как с обычным объектом. Способы оптимизации, используемые для массивов, в этом случае не подходят, поэтому они будут отключены и никакой выгоды не принесут.</p>
    <p>Варианты неправильного применения массива:</p>
    <ul>
      <li>Добавление нечислового свойства, например: <code>arr.test = 5</code>.</li>
      <li>Создание «дыр», например: добавление <code>arr[0]</code>, затем <code>arr[1000]</code> (между ними ничего нет).</li>
      <li>Заполнение массива в обратном порядке, например: <code>arr[1000]</code>, <code>arr[999]</code> и т.д.</li>
    </ul>
    <p>Массив следует считать особой структурой, позволяющей работать с упорядоченными данными. Для этого массивы предоставляют специальные методы. Массивы тщательно настроены в движках JavaScript для работы с однотипными упорядоченными данными, поэтому, пожалуйста, используйте их именно в таких случаях. Если вам нужны произвольные ключи, вполне возможно, лучше подойдёт обычный объект <code>{}</code>.</p>

    <h3>Эффективность</h3>

    
  </article>
</body>
</html>