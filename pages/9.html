<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <link rel="shortcut icon" href="../images/image3.png" type="image/x-icon">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JS LAIR</title>
  <link rel="stylesheet" href="../styles/fonts.css">
  <link rel="stylesheet" href="../styles/style-pages.css">
  <link rel="stylesheet" href="../styles/prism.css">
  <script src="../scripts/prism.js" defer></script>
  <script src="../scripts/script.js" defer></script>
</head>
<body>
  
  <header class="header">
    <ul>
      <li><a href="../index.html">Дом</a></li>
      <li><a href="../pages/browse.html">Просмотр</a></li>
      <li><a href="../pages/other.html">Прочее</a></li>
      <li><a href="#">Проект</a></li>
    </ul>
  </header>

  <article>
    <h1>Массивы.</h1>
    <hr>
    <p>Для хранения упорядоченных коллекций существует особая структура данных, которая называется массив, <code>Array</code>.</p>
    <h3>Объявление</h3>
    <p>Существует два варианта синтаксиса для создания пустого массива:</p>
<pre>
  <code class="lang-js">
    let arr = new Array();
    let arr = [];
  </code>
</pre>
    <p>Практически всегда используется второй вариант синтаксиса. В скобках мы можем указать начальные значения элементов:</p>
<pre>
  <code class="lang-js">
    let fruits = ["Яблоко", "Апельсин", "Слива"];
  </code>
</pre>
    <p>Элементы массива нумеруются, начиная с нуля.</p>
    <p>Мы можем получить элемент, указав его номер в квадратных скобках:</p>
<pre>
  <code class="lang-js">
    let fruits = ["Яблоко", "Апельсин", "Слива"];

    alert( fruits[0] ); // Яблоко
    alert( fruits[1] ); // Апельсин
    alert( fruits[2] ); // Слива
  </code>
</pre>
    <p>Мы можем заменить элемент:</p>
<pre>
  <code class="lang-js">
    fruits[2] = 'Груша'; // теперь ["Яблоко", "Апельсин", "Груша"]
  </code>
</pre>
    <p>…Или добавить новый к существующему массиву:</p>
<pre>
  <code class="lang-js">
    fruits[3] = 'Лимон'; // теперь ["Яблоко", "Апельсин", "Груша", "Лимон"]
  </code>
</pre>
    <p>Общее число элементов массива содержится в его свойстве <code>length</code>:</p>
<pre>
  <code class="lang-js">
    let fruits = ["Яблоко", "Апельсин", "Слива"];

    alert( fruits.length ); // 3
  </code>
</pre>
    <p>Вывести массив целиком можно при помощи <code>alert</code>.</p>
<pre>
  <code class="lang-js">
    let fruits = ["Яблоко", "Апельсин", "Слива"];

    alert( fruits ); // Яблоко, Апельсин, Слива
  </code>
</pre>
    <p>В массиве могут храниться элементы любого типа.</p>
<pre>
  <code class="lang-js">
    // разные типы значений
    let arr = [ 'Яблоко', { name: 'Джон' }, true, function() { alert('привет'); } ];

    // получить элемент с индексом 1 (объект) и затем показать его свойство
    alert( arr[1].name ); // Джон

    // получить элемент с индексом 3 (функция) и выполнить её
    arr[3](); // привет
  </code>
</pre>
    
    <h3>Получение последних элементов при помощи «at»</h3>
    <p>Допустим, нам нужен последний элемент массива.</p>
    <p>Некоторые языки программирования позволяют использовать отрицательные индексы для той же цели, как-то так: <code>fruits[-1]</code>.</p>
    <p>Однако, в JavaScript такая запись не сработает. Её результатом будет <code>undefined</code>, поскольку индекс в квадратных скобках понимается буквально.</p>
    <p>Мы можем явно вычислить индекс последнего элемента, а затем получить к нему доступ вот так: <code>fruits[fruits.length - 1]</code>.</p>
<pre>
  <code class="lang-js">
    let fruits = ["Apple", "Orange", "Plum"];
    alert( fruits[fruits.length-1] ); // Plum
  </code>
</pre>
    <p>Немного громоздко, не так ли? Нам нужно дважды написать имя переменной.</p>
    <p>К счастью, есть более короткий синтаксис: <code>fruits.at(-1)</code>:</p>
<pre>
  <code class="lang-js">
    let fruits = ["Apple", "Orange", "Plum"];
    // то же самое, что и fruits[fruits.length-1]
    alert( fruits.at(-1) ); // Plum
  </code>
</pre>
    <p>Другими словами, <code>arr.at(i)</code>:</p>
    <ul>
      <li>это ровно то же самое, что и <code>arr[i]</code>, если <code>i >= 0</code>.</li>
      <li>для отрицательных значений <code>i</code>, он отступает от конца массива.</li>
    </ul>

    <h3>Методы pop/push, shift/unshift</h3>
    <p>Очередь – один из самых распространённых вариантов применения массива. В области компьютерных наук так называется упорядоченная коллекция элементов, поддерживающая два вида операций:</p>
    <ul>
      <li><code>push</code> добавляет элемент в конец.</li>
      <li><code>shift</code> удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым.</li>
    </ul>
    <ul><img src="../images/5.JPG" alt="1"></ul>
    <p>Массивы поддерживают обе операции.</p>
    <p>На практике необходимость в этом возникает очень часто. Например, очередь сообщений, которые надо показать на экране.</p>
    <p>Существует и другой вариант применения для массивов – структура данных, называемая стек.</p>
    <p>Она поддерживает два вида операций:</p>
    <ul>
      <li><code>push</code> добавляет элемент в конец.</li>
      <li><code>pop</code> удаляет последний элемент.</li>
    </ul>
    <p>Таким образом, новые элементы всегда добавляются или удаляются из «конца».</p>
    <p>Примером стека обычно служит колода карт: новые карты кладутся наверх и берутся тоже сверху:</p>
    <ul><img src="../images/6.JPG" alt="1"></ul>
    <p>Массивы в JavaScript могут работать и как очередь, и как стек. Мы можем добавлять/удалять элементы как в начало, так и в конец массива.</p>
    <p>В компьютерных науках структура данных, делающая это возможным, называется двусторонняя очередь.</p>
    <p><strong>Методы, работающие с концом массива:</strong></p>
    <p><code>pop</code></p>
    <p>Удаляет последний элемент из массива и возвращает его:</p>
<pre>
  <code class="lang-js">
    let fruits = ["Яблоко", "Апельсин", "Груша"];

    alert( fruits.pop() ); // удаляем "Груша" и выводим его

    alert( fruits ); // Яблоко, Апельсин
  </code>
</pre>
    <p>И <code>fruits.pop()</code> и <code>fruits.at(-1)</code> возвращают последний элемент массива, но <code>fruits.pop()</code> также изменяет массив, удаляя его.</p>
    <p><code>push</code></p>
    <p>Добавляет элемент в конец массива:</p>
<pre>
  <code class="lang-js">
    let fruits = ["Яблоко", "Апельсин"];

    fruits.push("Груша");

    alert( fruits ); // Яблоко, Апельсин, Груша
  </code>
</pre>
    <p>Вызов <code>fruits.push(...)</code> равнозначен <code>fruits[fruits.length] = ....</code></p>
    <p><strong>Методы, работающие с началом массива:</strong></p>
    <p><code>shift</code></p>
    <p>Удаляет из массива первый элемент и возвращает его:</p>
<pre>
  <code class="lang-js">
    let fruits = ["Яблоко", "Апельсин", "Груша"];

    alert( fruits.shift() ); // удаляем Яблоко и выводим его

    alert( fruits ); // Апельсин, Груша
  </code>
</pre>
    <p><code>unshift</code></p>
    <p>Добавляет элемент в начало массива:</p>
<pre>
  <code class="lang-js">
    let fruits = ["Апельсин", "Груша"];

    fruits.unshift('Яблоко');

    alert( fruits ); // Яблоко, Апельсин, Груша
  </code>
</pre>
    <p>Методы <code>push</code> и <code>unshift</code> могут добавлять сразу несколько элементов:</p>
<pre>
  <code class="lang-js">
    let fruits = ["Яблоко"];

    fruits.push("Апельсин", "Груша");
    fruits.unshift("Ананас", "Лимон");

    // ["Ананас", "Лимон", "Яблоко", "Апельсин", "Груша"]
    alert( fruits );
  </code>
</pre>

    <h3>Внутреннее устройство массива</h3>
    <p>Массив – это особый подвид объектов. Квадратные скобки, используемые для того, чтобы получить доступ к свойству arr[0] – это по сути обычный синтаксис доступа по ключу, как <code>obj[key]</code>, где в роли <code>obj</code> у нас <code>arr</code>, а в качестве ключа – числовой индекс.</p>
    <p>Массивы расширяют объекты, так как предусматривают специальные методы для работы с упорядоченными коллекциями данных, а также свойство <code>length</code>. Но в основе всё равно лежит объект.</p>
    <p>Следует помнить, что в JavaScript существует 8 основных типов данных. Массив является объектом и, следовательно, ведёт себя как объект.</p>
    <p>Например, копируется по ссылке:</p>
<pre>
  <code class="lang-js">
    let fruits = ["Банан"]

    let arr = fruits; // копируется по ссылке (две переменные ссылаются на один и тот же массив)

    alert( arr === fruits ); // true

    arr.push("Груша"); // массив меняется по ссылке

    alert( fruits ); // Банан, Груша - теперь два элемента
  </code>
</pre>
    <p>…Но то, что действительно делает массивы особенными – это их внутреннее представление. Движок JavaScript старается хранить элементы массива в непрерывной области памяти, один за другим, так, как это показано на иллюстрациях к этой главе. Существуют и другие способы оптимизации, благодаря которым массивы работают очень быстро.</p>
    <p>Но все они утратят эффективность, если мы перестанем работать с массивом как с «упорядоченной коллекцией данных» и начнём использовать его как обычный объект.</p>
    <p>Например, технически мы можем сделать следующее:</p>
<pre>
  <code class="lang-js">
    let fruits = []; // создаём массив

    fruits[99999] = 5; // создаём свойство с индексом, намного превышающим длину массива

    fruits.age = 25; // создаём свойство с произвольным именем
  </code>
</pre>
    <p>Это возможно, потому что в основе массива лежит объект. Мы можем присвоить ему любые свойства.</p>
    <p>Но движок поймёт, что мы работаем с массивом, как с обычным объектом. Способы оптимизации, используемые для массивов, в этом случае не подходят, поэтому они будут отключены и никакой выгоды не принесут.</p>
    <p>Варианты неправильного применения массива:</p>
    <ul>
      <li>Добавление нечислового свойства, например: <code>arr.test = 5</code>.</li>
      <li>Создание «дыр», например: добавление <code>arr[0]</code>, затем <code>arr[1000]</code> (между ними ничего нет).</li>
      <li>Заполнение массива в обратном порядке, например: <code>arr[1000]</code>, <code>arr[999]</code> и т.д.</li>
    </ul>
    <p>Массив следует считать особой структурой, позволяющей работать с упорядоченными данными. Для этого массивы предоставляют специальные методы. Массивы тщательно настроены в движках JavaScript для работы с однотипными упорядоченными данными, поэтому, пожалуйста, используйте их именно в таких случаях. Если вам нужны произвольные ключи, вполне возможно, лучше подойдёт обычный объект <code>{}</code>.</p>

    <h3>Эффективность</h3>
    <p>Методы <code>push/pop</code> выполняются быстро, а методы <code>shift/unshift</code> – медленно.</p>
    <ul><img src="../images/7.JPG" alt="1"></ul>
    <p>Почему работать с концом массива быстрее, чем с его началом? Давайте посмотрим, что происходит во время выполнения:</p>
<pre>
  <code class="lang-js">
    fruits.shift(); // удаляем первый элемент с начала
  </code>
</pre>
    <p>Просто взять и удалить элемент с номером 0 недостаточно. Нужно также заново пронумеровать остальные элементы.</p>
    <p>Операция <code>shift</code> должна выполнить 3 действия:</p>
    <ul>
      <li>Удалить элемент с индексом <code>0</code>.</li>
      <li>Сдвинуть все элементы влево, заново пронумеровать их, заменив <code>1</code> на <code>0</code>, <code>2</code> на <code>1</code> и т.д.</li>
      <li>Обновить свойство <code>length</code> .</li>
    </ul>
    <ul><img src="../images/8.JPG" alt="1"></ul>
    <p>Чем больше элементов содержит массив, тем больше времени потребуется для того, чтобы их переместить, больше операций с памятью.</p>
    <p>То же самое происходит с <code>unshift</code>: чтобы добавить элемент в начало массива, нам нужно сначала сдвинуть существующие элементы вправо, увеличивая их индексы.</p>
    <p>А что же с <code>push/pop</code>? Им не нужно ничего перемещать. Чтобы удалить элемент в конце массива, метод pop очищает индекс и уменьшает значение <code>length</code>.</p>
    <p>Действия при операции <code>pop</code>:</p>
<pre>
  <code class="lang-js">
    fruits.pop(); // удаляем один элемент с конца
  </code>
</pre>
    <p><ul><img src="../images/9.JPG" alt="1"></ul></p>
    <p>Метод <code>pop</code> не требует перемещения, потому что остальные элементы остаются с теми же индексами. Именно поэтому он выполняется очень быстро.</p>
    <p>Аналогично работает метод <code>push</code>.</p>

    <h3>Перебор элементов</h3>
    <p>Одним из самых старых способов перебора элементов массива является цикл <code>for</code> по цифровым индексам:</p>
<pre>
  <code class="lang-js">
    let arr = ["Яблоко", "Апельсин", "Груша"];

    for (let i = 0; i < arr.length; i++) {
      alert( arr[i] );
    }
  </code>
</pre>
    <p>Но для массивов возможен и другой вариант цикла, <code>for..of</code>:</p>
<pre>
  <code class="lang-js">
    let fruits = ["Яблоко", "Апельсин", "Слива"];

    // проходит по значениям
    for (let fruit of fruits) {
      alert( fruit );
    }
  </code>
</pre>
    <p>Цикл <code>for..of</code> не предоставляет доступа к номеру текущего элемента, только к его значению, но в большинстве случаев этого достаточно. А также это короче.</p>
    <p>Технически, так как массив является объектом, можно использовать и вариант <code>for..in</code>:</p>
<pre>
  <code class="lang-js">
    let arr = ["Яблоко", "Апельсин", "Груша"];

    for (let key in arr) {
      alert( arr[key] ); // Яблоко, Апельсин, Груша
    }
  </code>
</pre>
    <p>Но на самом деле это – плохая идея. Существуют скрытые недостатки этого способа:</p>
    <ul>
      <li>Цикл <code>for..in</code> выполняет перебор всех свойств объекта, а не только цифровых. В браузере и других программных средах также существуют так называемые «псевдомассивы» – объекты, которые выглядят, как массив. То есть, у них есть свойство <code>length</code> и индексы, но они также могут иметь дополнительные нечисловые свойства и методы, которые нам обычно не нужны. Тем не менее, цикл <code>for..in</code> выведет и их. Поэтому, если нам приходится иметь дело с объектами, похожими на массив, такие «лишние» свойства могут стать проблемой.</li>
      <li>Цикл <code>for..in</code> оптимизирован под произвольные объекты, не массивы, и поэтому в 10-100 раз медленнее. Увеличение скорости выполнения может иметь значение только при возникновении узких мест. Но мы всё же должны представлять разницу.</li>
    </ul>
    <p>В общем, не следует использовать цикл <code>for..in</code> для массивов.</p>

    <h3>Немного о «length»</h3>
    <p>Свойство <code>length</code> автоматически обновляется при изменении массива. Если быть точными, это не количество элементов массива, а наибольший цифровой индекс плюс один.</p>
    <p>Например, единственный элемент, имеющий большой индекс, даёт большую длину:</p>
<pre>
  <code class="lang-js">
    let fruits = [];
    fruits[123] = "Яблоко";

    alert( fruits.length ); // 124
  </code>
</pre>
    <p>Обратите внимание, что обычно мы не используем массивы таким образом.</p>
    <p>Ещё один интересный факт о свойстве <code>length</code> – его можно перезаписать.</p>
    <p>Если мы вручную увеличим его, ничего интересного не произойдёт. Зато, если мы уменьшим его, массив станет короче. Этот процесс необратим, как мы можем понять из примера:</p>
<pre>
  <code class="lang-js">
    let arr = [1, 2, 3, 4, 5];

    arr.length = 2; // укорачиваем до двух элементов
    alert( arr ); // [1, 2]

    arr.length = 5; // возвращаем length как было
    alert( arr[3] ); // undefined: значения не восстановились
  </code>
</pre>
    <p>Таким образом, самый простой способ очистить массив – это <code>arr.length = 0;</code>.</p>

    <h3>new Array()</h3>
    <p>Существует ещё один вариант синтаксиса для создания массива:</p>
<pre>
  <code class="lang-js">
    let arr = new Array("Яблоко", "Груша", "и тд");
  </code>
</pre>
    <p>Он редко применяется, так как квадратные скобки <code>[]</code> короче. Кроме того, у него есть хитрая особенность.</p>
    <p>Если <code>new Array</code> вызывается с одним аргументом, который представляет собой число, он создаёт массив без элементов, но с заданной длиной.</p>
    <p>Давайте посмотрим, как можно оказать себе медвежью услугу:</p>
<pre>
  <code class="lang-js">
    let arr = new Array(2); // создастся ли массив [2]?

    alert( arr[0] ); // undefined! нет элементов.

    alert( arr.length ); // length 2
  </code>
</pre>
    <p>Как мы видим, в коде, представленном выше, в <code>new Array(number)</code> все элементы равны <code>undefined</code>.</p>
    <p>Чтобы избежать появления таких неожиданных ситуаций, мы обычно используем квадратные скобки, если, конечно, не знаем точно, что по какой-то причине нужен именно <code>Array</code>.</p>

    <h3>Многомерные массивы</h3>
    <p>Массивы могут содержать элементы, которые тоже являются массивами. Это можно использовать для создания многомерных массивов, например, для хранения матриц:</p>
<pre>
  <code class="lang-js">
    let matrix = [
      [1, 2, 3],
      [4, 5, 6],
      [7, 8, 9]
    ];

    alert( matrix[1][1] ); // 5, центральный элемент
  </code>
</pre>
    
    <h3>toString</h3>
    <p>Массивы по-своему реализуют метод <code>toString</code>, который возвращает список элементов, разделённых запятыми.</p>
<pre>
  <code class="lang-js">
    let arr = [1, 2, 3];

    alert( arr ); // 1,2,3
    alert( String(arr) === '1,2,3' ); // true
  </code>
</pre>
    <p>Давайте теперь попробуем следующее:</p>
<pre>
  <code class="lang-js">
    alert( [] + 1 ); // "1"
    alert( [1] + 1 ); // "11"
    alert( [1,2] + 1 ); // "1,21"
  </code>
</pre>
    <p>Массивы не имеют ни <code>Symbol.toPrimitive</code>, ни функционирующего <code>valueOf</code>, они реализуют только преобразование <code>toString</code>, таким образом, здесь <code>[]</code> становится пустой строкой, <code>[1]</code> становится <code>"1"</code>, а <code>[1,2]</code> становится <code>"1,2"</code>.</p>
    <p>Когда бинарный оператор плюс <code>+</code> добавляет что-либо к строке, он тоже преобразует это в строку, таким образом:</p>
<pre>
  <code class="lang-js">
    alert( "" + 1 ); // "1"
    alert( "1" + 1 ); // "11"
    alert( "1,2" + 1 ); // "1,21"
  </code>
</pre>

    <h3>Не сравнивайте массивы при помощи <code>==</code></h3>
    <p>В JavaScript, в отличие от некоторых других языков программирования, массивы не следует сравнивать при помощи оператора <code>==</code>.</p>
    <p>У этого оператора нет специального подхода к массивам, он работает с ними, как и с любыми другими объектами.</p>
    <p>Давайте ещё раз напомним правила:</p>
    <ul>
      <li>Два объекта равны друг другу <code>==</code> только в том случае, если они ссылаются на один и тот же объект.</li>
      <li>Если один из аргументов <code>==</code> является объектом, а другой – примитивом, то объект преобразуется в примитив, как описано в главе Преобразование объектов в примитивы.</li>
      <li>…За исключением <code>null</code> и <code>undefined</code>, которые равны <code>==</code> друг другу и ничему больше.</li>
    </ul>
    <p>Оператор строгого равенства <code>===</code> ещё проще, так как он не преобразует типы.</p>
    <p>Итак, если мы всё же сравниваем массивы с помощью <code>==</code>, то они никогда не будут одинаковыми, если только мы не сравним две переменные, которые ссылаются на один и тот же массив</p>
    <p>Например:</p>
<pre>
  <code class="lang-js">
    alert( [] == [] ); // false
    alert( [0] == [0] ); // false
  </code>
</pre>
    <p>Технически эти массивы являются разными объектами. Так что они не равны. Оператор <code>==</code> не выполняет поэлементное сравнение.</p>
    <p>Сравнение с примитивами также может дать, казалось бы, странные результаты:</p>
<pre>
  <code class="lang-js">
    alert( 0 == [] ); // true

    alert('0' == [] ); // false
  </code>
</pre>
    <p>Здесь, в обоих случаях, мы сравниваем примитив с объектом массива. Таким образом, массив <code>[]</code> преобразуется в примитив с целью сравнения и становится пустой строкой <code>''</code>.</p>
    <p>Затем продолжается процесс сравнения с примитивами, как описано в главе Преобразование типов:</p>
<pre>
  <code class="lang-js">
    // после того, как [] был преобразован в ''
    alert( 0 == '' ); // true, так как '' преобразуется в число 0

    alert('0' == '' ); // false, нет преобразования типов, разные строки
  </code>
</pre>
    <p>Так как же сравнить массивы?</p>
    <p>Это просто: не используйте оператор <code>==</code>. Вместо этого сравните их по элементам в цикле или используя методы итерации, описанные в следующей главе.</p>
    
  </article>
</body>
</html>